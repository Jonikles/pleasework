======================================================================
// FILE: src\main\java\com\tutoringplatform\TutoringPlatformApplication.java
======================================================================

package com.tutoringplatform;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class TutoringPlatformApplication {

    public static void main(String[] args) {
        SpringApplication.run(TutoringPlatformApplication.class, args);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\command\ProcessPaymentCommand.java
======================================================================

package com.tutoringplatform.command;

import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IPaymentCommand;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;

public class ProcessPaymentCommand implements IPaymentCommand {
    private Payment payment;
    private Student student;
    private double amount;
    private IPaymentRepository paymentRepository;
    private IStudentRepository studentRepository;

    public ProcessPaymentCommand(Payment payment, Student student, double amount, IPaymentRepository paymentRepository, IStudentRepository studentRepository) {
        this.payment = payment;
        this.student = student;
        this.amount = amount;
        this.paymentRepository = paymentRepository;
        this.studentRepository = studentRepository;
    }

    @Override
    public void execute() throws Exception {
        student.deductFunds(amount);
        payment.setStatus(Payment.PaymentStatus.COMPLETED);
        paymentRepository.save(payment);
        studentRepository.update(student);
    }

    @Override
    public void undo() throws Exception {
        student.addFunds(amount);
        payment.setStatus(Payment.PaymentStatus.REFUNDED);
        paymentRepository.update(payment);
        studentRepository.update(student);
    }

    @Override
    public Payment getPayment() {
        return payment;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\command\RefundPaymentCommand.java
======================================================================

package com.tutoringplatform.command;


import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IPaymentCommand;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;

public class RefundPaymentCommand implements IPaymentCommand {
    private Payment payment;
    private Student student;
    private double amount;
    private IPaymentRepository paymentRepository;
    private IStudentRepository studentRepository;

    public RefundPaymentCommand(Payment payment, Student student, double amount, IPaymentRepository paymentRepository, IStudentRepository studentRepository) {
        this.payment = payment;
        this.student = student;
        this.amount = amount;
        this.paymentRepository = paymentRepository;
        this.studentRepository = studentRepository;
    }

    @Override
    public void execute() throws Exception {
        if (payment.getStatus() != Payment.PaymentStatus.COMPLETED) {
            throw new Exception("Can only refund completed payments");
        }
        student.addFunds(amount);
        payment.setStatus(Payment.PaymentStatus.REFUNDED);
        paymentRepository.update(payment);
        studentRepository.update(student);
    }

    @Override
    public void undo() throws Exception {
        student.deductFunds(amount);
        payment.setStatus(Payment.PaymentStatus.COMPLETED);
        paymentRepository.update(payment);
        studentRepository.update(student);
    }

    @Override
    public Payment getPayment() {
        return payment;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\config\BookingConfiguration.java
======================================================================

package com.tutoringplatform.config;

import com.tutoringplatform.services.BookingService;
import com.tutoringplatform.observer.*;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import javax.annotation.PostConstruct;

@Configuration
public class BookingConfiguration {

    @Autowired
    private BookingService bookingService;

    @Autowired
    private ITutorRepository tutorRepository;

    @PostConstruct
    public void setupObservers() {
        BookingLogger bookingLogger = new BookingLogger();
        TutorUpdateObserver tutorUpdateObserver = new TutorUpdateObserver(tutorRepository);

        bookingService.addObserver(bookingLogger);
        bookingService.addObserver(tutorUpdateObserver);

        System.out.println("Booking observers configured: Logger and TutorUpdater registered");
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\config\DataInitializationConfiguration.java
======================================================================

package com.tutoringplatform.config;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

import com.tutoringplatform.services.BookingService;
import com.tutoringplatform.services.PaymentService;
import com.tutoringplatform.services.ReviewService;
import com.tutoringplatform.services.StudentService;
import com.tutoringplatform.services.SubjectService;
import com.tutoringplatform.services.TutorService;
import com.tutoringplatform.util.DataInitializer;

@Configuration
@Profile("!test")
public class DataInitializationConfiguration {

    @Bean
    CommandLineRunner init(SubjectService subjectService, TutorService tutorService, StudentService studentService,
            BookingService bookingService, PaymentService paymentService, ReviewService reviewService) {
        return args -> {
            DataInitializer.initializeAllData(subjectService, tutorService, studentService, bookingService,
                    paymentService, reviewService);
            System.out.println("Application started! Access at http://localhost:8080");
        };
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\AuthController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.models.*;
import com.tutoringplatform.services.AuthService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        try {
            User user = authService.login(request.email, request.password);
            return ResponseEntity.ok(user);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(e.getMessage());
        }
    }

    @PostMapping("/signup/student")
    public ResponseEntity<?> signupStudent(@RequestBody StudentSignupRequest request) {
        try {
            Student student = authService.signupStudent(request.name, request.email, request.password);
            return ResponseEntity.ok(student);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    @PostMapping("/signup/tutor")
    public ResponseEntity<?> signupTutor(@RequestBody TutorSignupRequest request) {
        try {
            Tutor tutor = authService.signupTutor(request.name, request.email, request.password, request.hourlyRate, request.description);
            return ResponseEntity.ok(tutor);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    static class LoginRequest {
        public String email;
        public String password;
    }

    static class StudentSignupRequest {
        public String name;
        public String email;
        public String password;
    }

    static class TutorSignupRequest {
        public String name;
        public String email;
        public String password;
        public double hourlyRate;
        public String description;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\BookingController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.models.*;
import com.tutoringplatform.services.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/bookings")
@CrossOrigin(origins = "*")
public class BookingController {

    @Autowired
    private BookingService bookingService;

    @Autowired
    private PaymentService paymentService;

    @Autowired
    private SubjectService subjectService;

    @PostMapping
    public ResponseEntity<?> createBooking(@RequestBody BookingRequest request) {
        try {
            Subject subject = subjectService.findById(request.subjectId);
            Booking booking = bookingService.createBooking(request.studentId, request.tutorId, subject, request.dateTime, request.durationHours);
            return ResponseEntity.status(HttpStatus.CREATED).body(booking);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getBooking(@PathVariable String id) {
        try {
            Booking booking = bookingService.findById(id);
            return ResponseEntity.ok(booking);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/student/{studentId}")
    public ResponseEntity<?> getStudentBookings(@PathVariable String studentId) {
        List<Booking> bookings = bookingService.findByStudent(studentId);
        return ResponseEntity.ok(bookings);
    }

    @GetMapping("/tutor/{tutorId}")
    public ResponseEntity<?> getTutorBookings(@PathVariable String tutorId) {
        List<Booking> bookings = bookingService.findByTutor(tutorId);
        return ResponseEntity.ok(bookings);
    }

    @PostMapping("/{id}/confirm")
    public ResponseEntity<?> confirmBooking(@PathVariable String id, @RequestBody PaymentRequest request) {
        try {
            Booking booking = bookingService.findById(id);
            Payment payment = paymentService.processPayment(request.studentId, id, booking.getTotalCost());
            bookingService.confirmBooking(id, payment);
            return ResponseEntity.ok(booking);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<?> cancelBooking(@PathVariable String id) {
        try {
            bookingService.cancelBooking(id);
            return ResponseEntity.ok("Booking cancelled successfully");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/complete")
    public ResponseEntity<?> completeBooking(@PathVariable String id) {
        try {
            bookingService.completeBooking(id);
            return ResponseEntity.ok("Booking completed successfully");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    static class BookingRequest {
        public String studentId;
        public String tutorId;
        public String subjectId;
        public LocalDateTime dateTime;
        public int durationHours;
    }

    static class PaymentRequest {
        public String studentId;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\ReviewController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.models.Review;
import com.tutoringplatform.services.ReviewService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.util.List;

@RestController
@RequestMapping("/api/reviews")
@CrossOrigin(origins = "*")
public class ReviewController {

    @Autowired
    private ReviewService reviewService;

    @PostMapping
    public ResponseEntity<?> createReview(@RequestBody ReviewRequest request) {
        try {
            Review review = reviewService.createReview(
                    request.bookingId,
                    request.rating,
                    request.comment);
            return ResponseEntity.status(HttpStatus.CREATED).body(review);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/tutor/{tutorId}")
    public ResponseEntity<?> getTutorReviews(@PathVariable String tutorId) {
        List<Review> reviews = reviewService.findByTutor(tutorId);
        return ResponseEntity.ok(reviews);
    }

    @GetMapping("/student/{studentId}")
    public ResponseEntity<?> getStudentReviews(@PathVariable String studentId) {
        List<Review> reviews = reviewService.findByStudent(studentId);
        return ResponseEntity.ok(reviews);
    }

    static class ReviewRequest {
        public String bookingId;
        public int rating;
        public String comment;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\StudentController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.services.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.util.List;
import java.util.Map;


@RestController
@RequestMapping("/api/students")
@CrossOrigin(origins = "*")
public class StudentController {

    @Autowired
    private StudentService studentService;

    @GetMapping("/{id}")
    public ResponseEntity<?> getStudent(@PathVariable String id) {
        try {
            Student student = studentService.findById(id);
            return ResponseEntity.ok(student);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateStudent(@PathVariable String id, @RequestBody Student student) {
        try {
            if (!id.equals(student.getId())) {
                return ResponseEntity.badRequest().body("ID mismatch");
            }
            studentService.update(student);
            return ResponseEntity.ok(student);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/add-funds")
    public ResponseEntity<?> addFunds(@PathVariable String id, @RequestBody Map<String, Double> request) {
        try {
            Double amount = request.get("amount");
            if (amount == null || amount <= 0) {
                return ResponseEntity.badRequest().body("Invalid amount");
            }
            studentService.addFunds(id, amount);
            Student student = studentService.findById(id);
            return ResponseEntity.ok(Map.of("balance", student.getBalance()));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}/balance")
    public ResponseEntity<?> getBalance(@PathVariable String id) {
        try {
            Student student = studentService.findById(id);
            return ResponseEntity.ok(Map.of("balance", student.getBalance()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/search")
    public ResponseEntity<?> searchByName(@RequestParam String name) {
        List<Student> students = studentService.searchByName(name);
        return ResponseEntity.ok(students);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\SubjectController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.services.SubjectService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.util.List;

@RestController
@RequestMapping("/api/subjects")
@CrossOrigin(origins = "*")
public class SubjectController {

    @Autowired
    private SubjectService subjectService;

    @GetMapping
    public ResponseEntity<?> getAllSubjects() {
        List<Subject> subjects = subjectService.findAll();
        return ResponseEntity.ok(subjects);
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getSubjectById(@PathVariable String id) {
        try {
            Subject subject = subjectService.findById(id);
            return ResponseEntity.ok(subject);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/name/{name}")
    public ResponseEntity<?> getSubjectByName(@PathVariable String name) {
        try {
            Subject subject = subjectService.findByName(name);
            return ResponseEntity.ok(subject);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/category/{category}")
    public ResponseEntity<?> getSubjectsByCategory(@PathVariable String category) {
        List<Subject> subjects = subjectService.findByCategory(category);
        return ResponseEntity.ok(subjects);
    }

    @PostMapping
    public ResponseEntity<?> createSubject(@RequestBody SubjectRequest request) {
        try {
            Subject subject = subjectService.createSubject(request.name, request.category);
            return ResponseEntity.status(HttpStatus.CREATED).body(subject);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    static class SubjectRequest {
        public String name;
        public String category;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\TutorController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.models.*;
import com.tutoringplatform.services.TutorService;
import com.tutoringplatform.services.SubjectService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/tutors")
@CrossOrigin(origins = "*")
public class TutorController {

    @Autowired
    private TutorService tutorService;

    @Autowired
    private SubjectService subjectService;

    @GetMapping("/{id}")
    public ResponseEntity<?> getTutor(@PathVariable String id) {
        try {
            Tutor tutor = tutorService.findById(id);
            return ResponseEntity.ok(tutor);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping
    public ResponseEntity<?> getAllTutors() {
        List<Tutor> tutors = tutorService.findAll();
        return ResponseEntity.ok(tutors);
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateTutor(@PathVariable String id, @RequestBody Tutor tutor) {
        try {
            if (!id.equals(tutor.getId())) {
                return ResponseEntity.badRequest().body("ID mismatch");
            }
            tutorService.update(tutor);
            return ResponseEntity.ok(tutor);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/search")
    public ResponseEntity<?> searchTutors(
            @RequestParam(required = false) String subjectId,
            @RequestParam(required = false) Double minPrice,
            @RequestParam(required = false) Double maxPrice,
            @RequestParam(required = false) Double minRating,
            @RequestParam(required = false) String day,
            @RequestParam(required = false) Integer hour) {
        try {
            Subject subject = null;
            if (subjectId != null) {
                subject = subjectService.findById(subjectId);
            }
            List<Tutor> tutors = tutorService.searchTutors(subject, minPrice, maxPrice, minRating, day, hour);
            return ResponseEntity.ok(tutors);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/availability")
    public ResponseEntity<?> updateAvailability(
            @PathVariable String id,
            @RequestBody AvailabilityRequest request) {
        try {
            tutorService.updateAvailability(id, request.day, request.hour, request.add);
            Tutor tutor = tutorService.findById(id);
            return ResponseEntity.ok(tutor.getAvailability());
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/subjects/{subjectId}")
    public ResponseEntity<?> addSubject(@PathVariable String id, @PathVariable String subjectId) {
        try {
            Subject subject = subjectService.findById(subjectId);
            Tutor tutor = tutorService.findById(id);
            tutor.addSubject(subject);
            tutorService.update(tutor);
            return ResponseEntity.ok(tutor.getSubjects());
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @DeleteMapping("/{id}/subjects/{subjectId}")
    public ResponseEntity<?> removeSubject(@PathVariable String id, @PathVariable String subjectId) {
        try {
            Subject subject = subjectService.findById(subjectId);
            Tutor tutor = tutorService.findById(id);
            tutor.removeSubject(subject);
            tutorService.update(tutor);
            return ResponseEntity.ok(tutor.getSubjects());
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}/earnings")
    public ResponseEntity<?> getEarnings(@PathVariable String id) {
        try {
            Tutor tutor = tutorService.findById(id);
            return ResponseEntity.ok(Map.of("earnings", tutor.getEarnings()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    static class AvailabilityRequest {
        public String day;
        public int hour;
        public boolean add;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\controllers\UserController.java
======================================================================

package com.tutoringplatform.controllers;


import com.tutoringplatform.models.User;
import com.tutoringplatform.services.UserService;

public abstract class UserController<T extends User> {
    protected UserService<T> userService;

    public UserController(UserService<T> userService) {
        this.userService = userService;
    }

    public T getUser(String id) throws Exception {
        return userService.findById(id);
    }

    public T getUserByEmail(String email) throws Exception {
        return userService.findByEmail(email);
    }

    public void updateUser(T user) throws Exception {
        userService.update(user);
    }

    public void deleteUser(String id) throws Exception {
        userService.delete(id);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\Booking.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;
import java.util.UUID;

public class Booking {
    private String id;
    private String studentId;
    private String tutorId;
    private Subject subject;
    private LocalDateTime dateTime;
    private int durationHours;
    private double totalCost;
    private BookingStatus status;
    private Payment payment;

    public enum BookingStatus {
        PENDING, CONFIRMED, COMPLETED, CANCELLED
    }

    public Booking(String studentId, String tutorId, Subject subject, LocalDateTime dateTime, int durationHours, double hourlyRate) {
        this.id = UUID.randomUUID().toString();
        this.studentId = studentId;
        this.tutorId = tutorId;
        this.subject = subject;
        this.dateTime = dateTime;
        this.durationHours = durationHours;
        this.totalCost = hourlyRate * durationHours;
        this.status = BookingStatus.PENDING;
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getStudentId() { return studentId; }
    public void setStudentId(String studentId) { this.studentId = studentId; }

    public String getTutorId() { return tutorId; }
    public void setTutorId(String tutorId) { this.tutorId = tutorId; }

    public Subject getSubject() { return subject; }
    public void setSubject(Subject subject) { this.subject = subject; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public int getDurationHours() { return durationHours; }
    public void setDurationHours(int durationHours) { this.durationHours = durationHours; }

    public double getTotalCost() { return totalCost; }
    public void setTotalCost(double totalCost) { this.totalCost = totalCost; }

    public BookingStatus getStatus() { return status; }
    public void setStatus(BookingStatus status) { this.status = status; }

    public Payment getPayment() { return payment; }
    public void setPayment(Payment payment) { this.payment = payment; }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\Payment.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;
import java.util.UUID;

public class Payment {
    private String id;
    private String bookingId;
    private double amount;
    private PaymentStatus status;
    private LocalDateTime timestamp;
    private String transactionId;

    public enum PaymentStatus {
        PENDING, COMPLETED, FAILED, REFUNDED
    }

    public Payment(String bookingId, double amount) {
        this.id = UUID.randomUUID().toString();
        this.bookingId = bookingId;
        this.amount = amount;
        this.status = PaymentStatus.PENDING;
        this.timestamp = LocalDateTime.now();
        this.transactionId = UUID.randomUUID().toString();
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getBookingId() { return bookingId; }
    public void setBookingId(String bookingId) { this.bookingId = bookingId; }

    public double getAmount() { return amount; }
    public void setAmount(double amount) { this.amount = amount; }

    public PaymentStatus getStatus() { return status; }
    public void setStatus(PaymentStatus status) { this.status = status; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\Review.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;
import java.util.UUID;

public class Review {
    private String id;
    private String studentId;
    private String tutorId;
    private String bookingId;
    private int rating;
    private String comment;
    private LocalDateTime timestamp;

    public Review(String studentId, String tutorId, String bookingId, int rating, String comment) {
        this.id = UUID.randomUUID().toString();
        this.studentId = studentId;
        this.tutorId = tutorId;
        this.bookingId = bookingId;
        setRating(rating);
        this.comment = comment;
        this.timestamp = LocalDateTime.now();
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getStudentId() { return studentId; }
    public void setStudentId(String studentId) { this.studentId = studentId; }

    public String getTutorId() { return tutorId; }
    public void setTutorId(String tutorId) { this.tutorId = tutorId; }

    public String getBookingId() { return bookingId; }
    public void setBookingId(String bookingId) { this.bookingId = bookingId; }

    public int getRating() { return rating; }

    public void setRating(int rating) {
        if (rating < 1 || rating > 5) {
            throw new IllegalArgumentException("Rating must be between 1 and 5");
        }
        this.rating = rating;
    }

    public String getComment() { return comment; }
    public void setComment(String comment) { this.comment = comment; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\Student.java
======================================================================

package com.tutoringplatform.models;

import java.util.ArrayList;
import java.util.List;

public class Student extends User {
    private List<Review> reviewsGiven;
    private double balance;

    public Student(String name, String email, String password) {
        super(name, email, password, UserType.STUDENT);
        this.reviewsGiven = new ArrayList<>();
        this.balance = 0.0;
    }


    public List<Review> getReviewsGiven() {
        return reviewsGiven;
    }

    public void addReview(Review review) {
        reviewsGiven.add(review);
    }

    public void addFunds(double amount) {
        this.balance += amount;}

    public void deductFunds(double amount) throws Exception {
        if (balance < amount) {
            throw new Exception("Insufficient funds");
        }
        this.balance -= amount;
    }

    public double getBalance() { return balance; }
    public void setBalance(double balance) { this.balance = balance; }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\Subject.java
======================================================================

package com.tutoringplatform.models;

import java.util.UUID;

public class Subject {
    private String id;
    private String name;
    private String category;

    public Subject(String name, String category) {
        this.id = UUID.randomUUID().toString();
        this.name = name;
        this.category = category;
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getCategory() { return category; }
    public void setCategory(String category) { this.category = category; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || getClass() != obj.getClass())
            return false;
        Subject subject = (Subject) obj;
        return id.equals(subject.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\Tutor.java
======================================================================

package com.tutoringplatform.models;

import java.util.*;
import java.time.LocalDateTime;

public class Tutor extends User {
    private List<Subject> subjects;
    private double hourlyRate;
    private String description;
    private List<Review> reviewsReceived;
    private Map<String, List<Integer>> availability;
    private double earnings;

    public Tutor(String name, String email, String password, double hourlyRate, String description) {
        super(name, email, password, UserType.TUTOR);
        this.subjects = new ArrayList<>();
        this.hourlyRate = hourlyRate;
        this.description = description;
        this.reviewsReceived = new ArrayList<>();
        this.availability = new HashMap<>();
        this.earnings = 0.0;
        initializeAvailability();
    }

    private void initializeAvailability() {
        String[] days = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
        for (String day : days) {
            availability.put(day, new ArrayList<>());
        }
    }

    public void addAvailability(String day, int hour) {
        if (hour >= 0 && hour <= 23 && availability.containsKey(day)) {
            if (!availability.get(day).contains(hour)) {
                availability.get(day).add(hour);
                Collections.sort(availability.get(day));
            }
        }
    }

    public void addAvailability(LocalDateTime dateTime, int durationHours) {
        String day = dateTime.getDayOfWeek().toString().substring(0, 1)
                + dateTime.getDayOfWeek().toString().substring(1).toLowerCase();
        int startHour = dateTime.getHour();

        // Add each hour in the duration
        for (int i = 0; i < durationHours; i++) {
            int hour = startHour + i;
            if (hour < 24) {
                addAvailability(day, hour);
            }
        }
    }

    public void removeAvailability(String day, int hour) {
        if (availability.containsKey(day)) {
            availability.get(day).remove(Integer.valueOf(hour));
        }
    }

    public boolean isAvailable(String day, int hour) {
        return availability.containsKey(day) && availability.get(day).contains(hour);
    }

    public double getAverageRating() {
        if (reviewsReceived.isEmpty())
            return 0.0;
        return reviewsReceived.stream()
                .mapToDouble(Review::getRating)
                .average()
                .orElse(0.0);
    }

    public List<Subject> getSubjects() {
        return subjects;
    }

    public void addSubject(Subject subject) {
        if (!subjects.contains(subject))
            subjects.add(subject);
    }

    public void removeSubject(Subject subject) {
        subjects.remove(subject);
    }

    public void printUnavailableTimes() {
        System.out.println("\n=== Unavailable Times for " + this.name + " ===");
        String[] days = { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" };

        for (String day : days) {
            List<Integer> availableHours = availability.get(day);
            List<Integer> unavailableHours = new ArrayList<>();

            for (int hour = 0; hour < 24; hour++) {
                if (!availableHours.contains(hour)) {
                    unavailableHours.add(hour);
                }
            }

            if (!unavailableHours.isEmpty()) {
                System.out.println(day + ":");
                System.out.print("  Unavailable: ");

                int start = unavailableHours.get(0);
                int end = start;

                for (int i = 1; i <= unavailableHours.size(); i++) {
                    if (i < unavailableHours.size() && unavailableHours.get(i) == end + 1) {
                        end = unavailableHours.get(i);
                    } else {
                        if (start == end) {
                            System.out.print(String.format("%02d:00", start) + " ");
                        } else {
                            System.out.print(String.format("%02d:00", start) + "-" + String.format("%02d:00", end) + " ");
                        }

                        if (i < unavailableHours.size()) {
                            start = unavailableHours.get(i);
                            end = start;
                        }
                    }
                }
                System.out.println();
            }
        }
        System.out.println("================================\n");
    }

    public void addEarnings(double amount) {
        this.earnings += amount;
    }
    
    public List<Review> getReviewsReceived() {
        return reviewsReceived;
    }

    public void addReview(Review review) {
        reviewsReceived.add(review);
    }

    public double getHourlyRate() { return hourlyRate; }
    public void setHourlyRate(double hourlyRate) { this.hourlyRate = hourlyRate; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Map<String, List<Integer>> getAvailability() { return availability; }
    public void setAvailability(Map<String, List<Integer>> availability) { this.availability = availability; }

    public double getEarnings() { return earnings; }
    public void setEarnings(double earnings) { this.earnings = earnings; }

}



======================================================================
// FILE: src\main\java\com\tutoringplatform\models\User.java
======================================================================

package com.tutoringplatform.models;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public abstract class User {
    protected String id;
    protected String name;
    protected String email;
    protected String password;
    protected UserType userType;
    protected List<Booking> bookings;

    public enum UserType {
        STUDENT, TUTOR
    }

    public User(String name, String email, String password, UserType userType) {
        this.id = UUID.randomUUID().toString();
        this.name = name;
        this.email = email;
        this.password = password;
        this.userType = userType;
        this.bookings = new ArrayList<>();
    }

    public void addBooking(Booking booking) {
        bookings.add(booking);
    }

    public void removeBooking(Booking booking) {
        bookings.remove(booking);
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public UserType getUserType() { return userType; }
    public void setUserType(UserType userType) { this.userType = userType; }

    public List<Booking> getBookings() { return bookings; }
    public void setBookings(List<Booking> bookings) { this.bookings = bookings; }

}



======================================================================
// FILE: src\main\java\com\tutoringplatform\observer\BookingEvent.java
======================================================================

package com.tutoringplatform.observer;

import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;

public class BookingEvent {
    private EventType eventType;
    private Booking booking;
    private Student student;
    private Tutor tutor;

    public enum EventType {
        CREATED, CONFIRMED, CANCELLED, COMPLETED
    }

    public BookingEvent(EventType eventType, Booking booking, Student student, Tutor tutor) {
        this.eventType = eventType;
        this.booking = booking;
        this.student = student;
        this.tutor = tutor;
    }

    public EventType getEventType() { return eventType; }

    public Booking getBooking() { return booking; }

    public Student getStudent() { return student; }

    public Tutor getTutor() { return tutor; }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\observer\BookingLogger.java
======================================================================

package com.tutoringplatform.observer;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class BookingLogger implements BookingObserver {
    private List<String> logs;
    private DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public BookingLogger() {
        this.logs = new ArrayList<>();
    }

    @Override
    public void update(BookingEvent event) {
        String logEntry = String.format("[%s] Booking %s: %s - Student: %s, Tutor: %s, Subject: %s",
                LocalDateTime.now().format(formatter),
                event.getEventType(),
                event.getBooking().getId(),
                event.getStudent().getName(),
                event.getTutor().getName(),
                event.getBooking().getSubject().getName());

        logs.add(logEntry);
        System.out.println("LOG: " + logEntry);
    }

    public List<String> getLogs() {
        return new ArrayList<>(logs);
    }

    public void printAllLogs() {
        System.out.println("\n=== BOOKING LOGS ===");
        for (String log : logs) {
            System.out.println(log);
        }
        System.out.println("==================\n");
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\observer\BookingObserver.java
======================================================================

package com.tutoringplatform.observer;

public interface BookingObserver {
    void update(BookingEvent event);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\observer\TutorUpdateObserver.java
======================================================================

package com.tutoringplatform.observer;

import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

public class TutorUpdateObserver implements BookingObserver {
    private ITutorRepository tutorRepository;

    public TutorUpdateObserver(ITutorRepository tutorRepository) {
        this.tutorRepository = tutorRepository;
    }

    @Override
    public void update(BookingEvent event) {
        Tutor tutor = event.getTutor();
        String day = event.getBooking().getDateTime().getDayOfWeek().toString().substring(0, 1)
                + event.getBooking().getDateTime().getDayOfWeek().toString().substring(1).toLowerCase();
        int startHour = event.getBooking().getDateTime().getHour();

        if (event.getEventType() == BookingEvent.EventType.CONFIRMED) {
            for (int i = 0; i < event.getBooking().getDurationHours(); i++) {
                tutor.removeAvailability(day, startHour + i);
            }
            System.out.println("TutorUpdateObserver: Updated tutor availability after booking confirmation for " + day
                    + " at " + startHour + "h.");
            tutorRepository.update(tutor);

        } else if (event.getEventType() == BookingEvent.EventType.CANCELLED) {
            for (int i = 0; i < event.getBooking().getDurationHours(); i++) {
                tutor.addAvailability(day, startHour + i);
            }
            System.out.println("TutorUpdateObserver: Restored tutor availability after booking cancellation for " + day
                    + " at " + startHour + "h.");
            tutorRepository.update(tutor);
        }
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\impl\BookingRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Booking;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;

@Repository
public class BookingRepository implements IBookingRepository {
    private Map<String, Booking> bookings = new HashMap<>();

    @Override
    public Booking findById(String id) {
        return bookings.get(id);
    }

    @Override
    public List<Booking> findAll() {
        return new ArrayList<>(bookings.values());
    }

    @Override
    public List<Booking> findByStudentId(String studentId) {
        return bookings.values().stream()
                .filter(b -> b.getStudentId().equals(studentId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByTutorId(String tutorId) {
        return bookings.values().stream()
                .filter(b -> b.getTutorId().equals(tutorId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByStatus(Booking.BookingStatus status) {
        return bookings.values().stream()
                .filter(b -> b.getStatus() == status)
                .collect(Collectors.toList());
    }

    @Override
    public void save(Booking booking) {
        bookings.put(booking.getId(), booking);
    }

    @Override
    public void update(Booking booking) {
        bookings.put(booking.getId(), booking);
    }

    @Override
    public void delete(String id) {
        bookings.remove(id);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\impl\PaymentRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Payment;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;

@Repository
public class PaymentRepository implements IPaymentRepository {
    private Map<String, Payment> payments = new HashMap<>();

    @Override
    public Payment findById(String id) {
        return payments.get(id);
    }

    @Override
    public Payment findByBookingId(String bookingId) {
        return payments.values().stream()
                .filter(p -> p.getBookingId().equals(bookingId))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Payment> findAll() {
        return new ArrayList<>(payments.values());
    }

    @Override
    public void save(Payment payment) {
        payments.put(payment.getId(), payment);
    }

    @Override
    public void update(Payment payment) {
        payments.put(payment.getId(), payment);
    }

    @Override
    public void delete(String id) {
        payments.remove(id);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\impl\ReviewRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Review;
import com.tutoringplatform.repositories.interfaces.IReviewRepository;

@Repository
public class ReviewRepository implements IReviewRepository {
    private Map<String, Review> reviews = new HashMap<>();

    @Override
    public Review findById(String id) {
        return reviews.get(id);
    }

    @Override
    public List<Review> findAll() {
        return new ArrayList<>(reviews.values());
    }

    @Override
    public List<Review> findByTutorId(String tutorId) {
        return reviews.values().stream()
                .filter(r -> r.getTutorId().equals(tutorId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Review> findByStudentId(String studentId) {
        return reviews.values().stream()
                .filter(r -> r.getStudentId().equals(studentId))
                .collect(Collectors.toList());
    }

    @Override
    public Review findByBookingId(String bookingId) {
        return reviews.values().stream()
                .filter(r -> r.getBookingId().equals(bookingId))
                .findFirst()
                .orElse(null);
    }

    @Override
    public void save(Review review) {
        reviews.put(review.getId(), review);
    }

    @Override
    public void update(Review review) {
        reviews.put(review.getId(), review);
    }

    @Override
    public void delete(String id) {
        reviews.remove(id);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\impl\StudentRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;

@Repository
public class StudentRepository implements IStudentRepository {
    private Map<String, Student> students = new HashMap<>();

    @Override
    public Student findById(String id) {
        return students.get(id);
    }

    @Override
    public Student findByEmail(String email) {
        return students.values().stream()
                .filter(s -> s.getEmail().equals(email))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Student> findAll() {
        return new ArrayList<>(students.values());
    }

    @Override
    public void save(Student student) {
        students.put(student.getId(), student);
    }

    @Override
    public void update(Student student) {
        students.put(student.getId(), student);
    }

    @Override
    public void delete(String id) {
        students.remove(id);
    }

    @Override
    public List<Student> findByNameContaining(String name) {
        return students.values().stream()
                .filter(s -> s.getName().toLowerCase().contains(name.toLowerCase()))
                .collect(Collectors.toList());
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\impl\SubjectRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.repositories.interfaces.ISubjectRepository;

@Repository

public class SubjectRepository implements ISubjectRepository {
    private Map<String, Subject> subjects = new HashMap<>();

    @Override
    public Subject findById(String id) {
        return subjects.get(id);
    }

    @Override
    public Subject findByName(String name) {
        return subjects.values().stream()
                .filter(s -> s.getName().equalsIgnoreCase(name))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Subject> findAll() {
        return new ArrayList<>(subjects.values());
    }

    @Override
    public List<Subject> findByCategory(String category) {
        return subjects.values().stream()
                .filter(s -> s.getCategory().equalsIgnoreCase(category))
                .collect(Collectors.toList());
    }

    @Override
    public void save(Subject subject) {
        subjects.put(subject.getId(), subject);
    }

    @Override
    public void update(Subject subject) {
        subjects.put(subject.getId(), subject);
    }

    @Override
    public void delete(String id) {
        subjects.remove(id);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\impl\TutorRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

@Repository
public class TutorRepository implements ITutorRepository {
    private Map<String, Tutor> tutors = new HashMap<>();

    @Override
    public Tutor findById(String id) {
        return tutors.get(id);
    }

    @Override
    public Tutor findByEmail(String email) {
        return tutors.values().stream()
                .filter(t -> t.getEmail().equals(email))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Tutor> findAll() {
        return new ArrayList<>(tutors.values());
    }

    @Override
    public void save(Tutor tutor) {
        tutors.put(tutor.getId(), tutor);
    }

    @Override
    public void update(Tutor tutor) {
        tutors.put(tutor.getId(), tutor);
    }

    @Override
    public void delete(String id) {
        tutors.remove(id);
    }

    @Override
    public List<Tutor> findBySubject(Subject subject) {
        return tutors.values().stream()
                .filter(t -> t.getSubjects().contains(subject))
                .collect(Collectors.toList());
    }

    @Override
    public List<Tutor> findByHourlyRateBetween(double min, double max) {
        return tutors.values().stream()
                .filter(t -> t.getHourlyRate() >= min && t.getHourlyRate() <= max)
                .collect(Collectors.toList());
    }

    @Override
    public List<Tutor> findByMinimumRating(double rating) {
        return tutors.values().stream()
                .filter(t -> t.getAverageRating() >= rating)
                .collect(Collectors.toList());
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\IBookingRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Booking;

public interface IBookingRepository {
    Booking findById(String id);
    List<Booking> findAll();
    List<Booking> findByStudentId(String studentId);
    List<Booking> findByTutorId(String tutorId);
    List<Booking> findByStatus(Booking.BookingStatus status);
    void save(Booking booking);
    void update(Booking booking);
    void delete(String id);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\IPaymentCommand.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import com.tutoringplatform.models.Payment;

public interface IPaymentCommand {
    void execute() throws Exception;
    void undo() throws Exception;
    Payment getPayment();
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\IPaymentRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Payment;

public interface IPaymentRepository {
    Payment findById(String id);

    Payment findByBookingId(String bookingId);

    List<Payment> findAll();

    void save(Payment payment);

    void update(Payment payment);

    void delete(String id);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\IReviewRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Review;

public interface IReviewRepository {
    Review findById(String id);
    List<Review> findAll();
    List<Review> findByTutorId(String tutorId);
    List<Review> findByStudentId(String studentId);
    Review findByBookingId(String bookingId);
    void save(Review review);
    void update(Review review);
    void delete(String id);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\IStudentRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Student;

public interface IStudentRepository extends IUserRepository<Student> {
    List<Student> findByNameContaining(String name);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\ISubjectRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Subject;

public interface ISubjectRepository {
    Subject findById(String id);
    Subject findByName(String name);
    List<Subject> findAll();
    List<Subject> findByCategory(String category);
    void save(Subject subject);
    void update(Subject subject);
    void delete(String id);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\ITutorRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;

public interface ITutorRepository extends IUserRepository<Tutor> {
    List<Tutor> findBySubject(Subject subject);
    List<Tutor> findByHourlyRateBetween(double min, double max);
    List<Tutor> findByMinimumRating(double rating);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\repositories\interfaces\IUserRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.User;

public interface IUserRepository<T extends User> {
    T findById(String id);
    T findByEmail(String email);
    List<T> findAll();
    void save(T user);
    void update(T user);
    void delete(String id);
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\AuthService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.models.User;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class AuthService {
    @Autowired
    private IStudentRepository studentRepository;
    @Autowired
    private ITutorRepository tutorRepository;


    public User login(String email, String password) throws Exception {
        Student student = studentRepository.findByEmail(email);
        if (student != null && student.getPassword().equals(password)) {
            return student;
        }

        Tutor tutor = tutorRepository.findByEmail(email);
        if (tutor != null && tutor.getPassword().equals(password)) {
            return tutor;
        }

        throw new Exception("Invalid email or password");
    }

    public Student signupStudent(String name, String email, String password) throws Exception {
        if (studentRepository.findByEmail(email) != null || tutorRepository.findByEmail(email) != null) {
            throw new Exception("Email already exists");
        }

        Student student = new Student(name, email, password);
        studentRepository.save(student);
        return student;
    }

    public Tutor signupTutor(String name, String email, String password,
            double hourlyRate, String description) throws Exception {
        if (studentRepository.findByEmail(email) != null || tutorRepository.findByEmail(email) != null) {
            throw new Exception("Email already exists");
        }

        if (hourlyRate <= 0) {
            throw new Exception("Hourly rate must be positive");
        }

        Tutor tutor = new Tutor(name, email, password, hourlyRate, description);
        tutorRepository.save(tutor);
        return tutor;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\BookingService.java
======================================================================

package com.tutoringplatform.services;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.observer.BookingEvent;
import com.tutoringplatform.observer.BookingObserver;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import javax.annotation.PostConstruct;

@Service
public class BookingService {
    @Autowired
    private IBookingRepository bookingRepository;
    @Autowired
    private IStudentRepository studentRepository;
    @Autowired
    private ITutorRepository tutorRepository;
    private List<BookingObserver> observers;

    @PostConstruct
    public void init() {
        this.observers = new ArrayList<>();
    }

    public BookingService(IBookingRepository bookingRepository,
            IStudentRepository studentRepository,
            ITutorRepository tutorRepository) {
        this.bookingRepository = bookingRepository;
        this.studentRepository = studentRepository;
        this.tutorRepository = tutorRepository;
        this.observers = new ArrayList<>();
    }

    public void addObserver(BookingObserver observer) {
        observers.add(observer);
    }

    public void removeObserver(BookingObserver observer) {
        observers.remove(observer);
    }

    private void notifyObservers(BookingEvent event) {
        for (BookingObserver observer : observers) {
            observer.update(event);
        }
    }

    public Booking createBooking(String studentId, String tutorId, Subject subject,
            LocalDateTime dateTime, int durationHours) throws Exception {
        Student student = studentRepository.findById(studentId);
        if (student == null) {
            throw new Exception("Student not found");
        }

        Tutor tutor = tutorRepository.findById(tutorId);
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        if (!tutor.getSubjects().contains(subject)) {
            throw new Exception("Tutor does not teach this subject");
        }

        String day = dateTime.getDayOfWeek().toString().substring(0, 1)
                + dateTime.getDayOfWeek().toString().substring(1).toLowerCase();
        int hour = dateTime.getHour();
        for (int i = 0; i < durationHours; i++) {
            if (!tutor.isAvailable(day, hour + i)) {
                throw new Exception("Tutor is not available at this time");
            }
        }

        List<Booking> tutorBookings = bookingRepository.findByTutorId(tutorId);
        for (Booking b : tutorBookings) {
            if (b.getStatus() != Booking.BookingStatus.CANCELLED &&
                    isTimeConflict(b, dateTime, durationHours)) {
                throw new Exception("Time slot already booked");
            }
        }

        Booking booking = new Booking(studentId, tutorId, subject, dateTime, durationHours, tutor.getHourlyRate());
        bookingRepository.save(booking);

        notifyObservers(new BookingEvent(BookingEvent.EventType.CREATED, booking, student, tutor));

        return booking;
    }

    private boolean isTimeConflict(Booking existing, LocalDateTime newTime, int newDuration) {
        LocalDateTime existingStart = existing.getDateTime();
        LocalDateTime existingEnd = existingStart.plusHours(existing.getDurationHours());

        LocalDateTime newStart = newTime;
        LocalDateTime newEnd = newStart.plusHours(newDuration);

        return newStart.isBefore(existingEnd) && newEnd.isAfter(existingStart);
    }

    public void confirmBooking(String bookingId, Payment payment) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() != Booking.BookingStatus.PENDING) {
            throw new Exception("Booking is not in pending status");
        }

        booking.setPayment(payment);
        booking.setStatus(Booking.BookingStatus.CONFIRMED);
        bookingRepository.update(booking);

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());

        if (student != null) {
            student.addBooking(booking);
            studentRepository.update(student);
        } else {
            System.err.println("Student with ID " + booking.getStudentId() + " not found during booking confirmation.");
        }

        if (tutor != null) {
            tutor.addBooking(booking);
            tutorRepository.update(tutor);
        } else {
            System.err.println("Tutor with ID " + booking.getTutorId() + " not found during booking confirmation.");
        }

        notifyObservers(new BookingEvent(BookingEvent.EventType.CONFIRMED, booking, student, tutor));
    }

    public void cancelBooking(String bookingId) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() == Booking.BookingStatus.COMPLETED) {
            throw new Exception("Cannot cancel completed booking");
        }

        booking.setStatus(Booking.BookingStatus.CANCELLED);
        bookingRepository.update(booking);

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());

        if (student != null) {
            student.removeBooking(booking);
            studentRepository.update(student);
        } else {
            System.err.println("Student with ID " + booking.getStudentId() + " not found during booking cancellation.");
        }

        if (tutor != null) {
            tutor.removeBooking(booking);
            tutorRepository.update(tutor);
        } else {
            System.err.println("Tutor with ID " + booking.getTutorId() + " not found during booking cancellation.");
        }

        notifyObservers(new BookingEvent(BookingEvent.EventType.CANCELLED, booking, student, tutor));
    }

    public void completeBooking(String bookingId) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() != Booking.BookingStatus.CONFIRMED) {
            throw new Exception("Booking must be confirmed first");
        }

        booking.setStatus(Booking.BookingStatus.COMPLETED);
        bookingRepository.update(booking);

        Tutor tutor = tutorRepository.findById(booking.getTutorId());
        tutor.addEarnings(booking.getTotalCost());
        tutorRepository.update(tutor);

        Student student = studentRepository.findById(booking.getStudentId());

        notifyObservers(new BookingEvent(BookingEvent.EventType.COMPLETED, booking, student, tutor));
    }

    public Booking findById(String id) throws Exception {
        Booking booking = bookingRepository.findById(id);
        if (booking == null) {
            throw new Exception("Booking not found");
        }
        return booking;
    }

    public List<Booking> findByStudent(String studentId) {
        return bookingRepository.findByStudentId(studentId);
    }

    public List<Booking> findByTutor(String tutorId) {
        return bookingRepository.findByTutorId(tutorId);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\PaymentService.java
======================================================================

package com.tutoringplatform.services;

import java.util.Stack;

import com.tutoringplatform.command.ProcessPaymentCommand;
import com.tutoringplatform.command.RefundPaymentCommand;
import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;
import com.tutoringplatform.repositories.interfaces.IPaymentCommand;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import javax.annotation.PostConstruct;

@Service
public class PaymentService {
    @Autowired
    private IPaymentRepository paymentRepository;
    @Autowired
    private IStudentRepository studentRepository;
    @Autowired
    private IBookingRepository bookingRepository;
    private Stack<IPaymentCommand> commandHistory;

    @PostConstruct
    public void init() {
        this.commandHistory = new Stack<>();
    }

    public Payment processPayment(String studentId, String bookingId, double amount) throws Exception {
        Student student = studentRepository.findById(studentId);
        if (student == null) {
            throw new Exception("Student not found");
        }

        Payment payment = new Payment(bookingId, amount);

        ProcessPaymentCommand command = new ProcessPaymentCommand(
                payment, student, amount, paymentRepository, studentRepository);

        command.execute();
        commandHistory.push(command);

        return payment;
    }

    public void refundPayment(String paymentId) throws Exception {
        Payment payment = paymentRepository.findById(paymentId);
        if (payment == null) {
            throw new Exception("Payment not found");
        }

        Booking booking = bookingRepository.findById(payment.getBookingId());
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        if (student == null) {
            throw new Exception("Student not found");
        }

        RefundPaymentCommand command = new RefundPaymentCommand(
                payment, student, payment.getAmount(), paymentRepository, studentRepository);

        command.execute();
        commandHistory.push(command);
    }

    public void undoLastPaymentAction() throws Exception {
        if (commandHistory.isEmpty()) {
            throw new Exception("No payment action to undo");
        }

        IPaymentCommand lastCommand = commandHistory.pop();
        lastCommand.undo();
    }

    public Payment findById(String id) throws Exception {
        Payment payment = paymentRepository.findById(id);
        if (payment == null) {
            throw new Exception("Payment not found");
        }
        return payment;
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\ReviewService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;

import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Review;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;
import com.tutoringplatform.repositories.interfaces.IReviewRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class ReviewService {
    @Autowired
    private IReviewRepository reviewRepository;
    @Autowired
    private IBookingRepository bookingRepository;
    @Autowired
    private ITutorRepository tutorRepository;
    @Autowired
    private IStudentRepository studentRepository;

    public Review createReview(String bookingId, int rating, String comment) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() != Booking.BookingStatus.COMPLETED) {
            throw new Exception("Can only review completed bookings");
        }

        if (reviewRepository.findByBookingId(bookingId) != null) {
            throw new Exception("Review already exists for this booking");
        }

        if (rating < 1 || rating > 5) {
            throw new IllegalArgumentException("Rating must be between 1 and 5");
        }
        Review review = new Review(booking.getStudentId(), booking.getTutorId(), bookingId, rating, comment);
        reviewRepository.save(review);

        Tutor tutor = tutorRepository.findById(booking.getTutorId());
        if (tutor != null) {
            tutor.addReview(review);
            tutorRepository.update(tutor);
        } else {
            System.err.println("Tutor with ID " + booking.getTutorId() + " not found during review creation.");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        if (student != null) {
            student.addReview(review);
            studentRepository.update(student);
        } else {
            System.err.println("Student with ID " + booking.getStudentId() + " not found during review creation.");
        }

        return review;
    }

    public List<Review> findByTutor(String tutorId) {
        return reviewRepository.findByTutorId(tutorId);
    }

    public List<Review> findByStudent(String studentId) {
        return reviewRepository.findByStudentId(studentId);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\StudentService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class StudentService extends UserService<Student> {

    @Autowired
    public StudentService(IStudentRepository repository) {
        super(repository);
    }

    public void register(Student student) throws Exception {
        if (repository.findByEmail(student.getEmail()) != null) {
            throw new Exception("Email already exists");
        }
        repository.save(student);
    }

    public void addFunds(String studentId, double amount) throws Exception {
        if (amount <= 0) {
            throw new Exception("Amount must be positive");
        }
        Student student = findById(studentId);
        student.addFunds(amount);
        repository.update(student);
    }

    public List<Student> searchByName(String name) {
        return ((IStudentRepository) repository).findByNameContaining(name);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\SubjectService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.repositories.interfaces.ISubjectRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class SubjectService {
    @Autowired
    private ISubjectRepository subjectRepository;

    public Subject createSubject(String name, String category) throws Exception {
        if (subjectRepository.findByName(name) != null) {
            throw new Exception("Subject already exists");
        }

        Subject subject = new Subject(name, category);
        subjectRepository.save(subject);
        return subject;
    }

    public Subject findById(String id) throws Exception {
        Subject subject = subjectRepository.findById(id);
        if (subject == null) {
            throw new Exception("Subject not found");
        }
        return subject;
    }

    public Subject findByName(String name) throws Exception {
        Subject subject = subjectRepository.findByName(name);
        if (subject == null) {
            throw new Exception("Subject not found");
        }
        return subject;
    }

    public List<Subject> findAll() {
        return subjectRepository.findAll();
    }

    public List<Subject> findByCategory(String category) {
        return subjectRepository.findByCategory(category);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\TutorService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;
import java.util.stream.Collectors;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class TutorService extends UserService<Tutor> {
    @Autowired
    public TutorService(ITutorRepository repository) {
        super(repository);
    }

    public void register(Tutor tutor) throws Exception {
        if (repository.findByEmail(tutor.getEmail()) != null) {
            throw new Exception("Email already exists");
        }
        if (tutor.getHourlyRate() <= 0) {
            throw new Exception("Hourly rate must be positive");
        }
        repository.save(tutor);
    }

    public List<Tutor> searchTutors(Subject subject, Double minPrice, Double maxPrice,
            Double minRating, String day, Integer hour) {
        List<Tutor> tutors = repository.findAll();

        if (subject != null) {
            tutors = tutors.stream()
                    .filter(t -> t.getSubjects().contains(subject))
                    .collect(Collectors.toList());
        }

        if (minPrice != null) {
            tutors = tutors.stream()
                    .filter(t -> t.getHourlyRate() >= minPrice)
                    .collect(Collectors.toList());
        }

        if (maxPrice != null) {
            tutors = tutors.stream()
                    .filter(t -> t.getHourlyRate() <= maxPrice)
                    .collect(Collectors.toList());
        }

        if (minRating != null) {
            tutors = tutors.stream()
                    .filter(t -> t.getAverageRating() >= minRating)
                    .collect(Collectors.toList());
        }

        if (day != null && hour != null) {
            tutors = tutors.stream()
                    .filter(t -> t.isAvailable(day, hour))
                    .collect(Collectors.toList());
        }

        return tutors;
    }

    public void updateAvailability(String tutorId, String day, int hour, boolean add) throws Exception {
        Tutor tutor = findById(tutorId);
        if (add) {
            tutor.addAvailability(day, hour);
        } else {
            tutor.removeAvailability(day, hour);
        }
        repository.update(tutor);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\services\UserService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;

import com.tutoringplatform.models.User;
import com.tutoringplatform.repositories.interfaces.IUserRepository;

public abstract class UserService<T extends User> {
    protected IUserRepository<T> repository;

    public UserService(IUserRepository<T> repository) {
        this.repository = repository;
    }

    public T findById(String id) throws Exception {
        T user = repository.findById(id);
        if (user == null) {
            throw new Exception("User not found with id: " + id);
        }
        return user;
    }

    public T findByEmail(String email) throws Exception {
        T user = repository.findByEmail(email);
        if (user == null) {
            throw new Exception("User not found with email: " + email);
        }
        return user;
    }

    public List<T> findAll() {
        return repository.findAll();
    }

    public void update(T user) throws Exception {
        if (repository.findById(user.getId()) == null) {
            throw new Exception("User not found");
        }
        repository.update(user);
    }

    public void delete(String id) throws Exception {
        if (repository.findById(id) == null) {
            throw new Exception("User not found");
        }
        repository.delete(id);
    }
}



======================================================================
// FILE: src\main\java\com\tutoringplatform\util\DataInitializer.java
======================================================================

package com.tutoringplatform.util;

import com.tutoringplatform.models.*;
import com.tutoringplatform.services.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class DataInitializer {

    private static List<Subject> subjects = new ArrayList<>();
    private static List<Student> students = new ArrayList<>();
    private static List<Tutor> tutors = new ArrayList<>();

    public static void initializeSubjects(SubjectService subjectService) {
        try {
            // Math subjects
            subjects.add(subjectService.createSubject("Algebra", "Mathematics"));
            subjects.add(subjectService.createSubject("Calculus", "Mathematics"));
            subjects.add(subjectService.createSubject("Geometry", "Mathematics"));
            subjects.add(subjectService.createSubject("Statistics", "Mathematics"));

            // Science subjects
            subjects.add(subjectService.createSubject("Physics", "Science"));
            subjects.add(subjectService.createSubject("Chemistry", "Science"));
            subjects.add(subjectService.createSubject("Biology", "Science"));

            // Language subjects
            subjects.add(subjectService.createSubject("English", "Language"));
            subjects.add(subjectService.createSubject("Spanish", "Language"));
            subjects.add(subjectService.createSubject("French", "Language"));

            // Programming subjects
            subjects.add(subjectService.createSubject("Java", "Programming"));
            subjects.add(subjectService.createSubject("Python", "Programming"));
            subjects.add(subjectService.createSubject("JavaScript", "Programming"));

            System.out.println("Subjects initialized: " + subjects.size() + " subjects created");
        } catch (Exception e) {
            System.err.println("Error initializing subjects: " + e.getMessage());
        }
    }

    public static void initializeTutors(TutorService tutorService, SubjectService subjectService) {
        try {
            // Tutor 1
            Tutor mathTutor = new Tutor("Dr. Sarah Johnson", "sarah@tutor.com", "password123",
                    75.0, "PhD in Mathematics with 15 years teaching experience");
            tutorService.register(mathTutor);

            mathTutor.addSubject(subjectService.findByName("Algebra"));
            mathTutor.addSubject(subjectService.findByName("Calculus"));
            mathTutor.addSubject(subjectService.findByName("Geometry"));

            String[] weekdays = { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday" };
            for (String day : weekdays) {
                for (int hour = 14; hour <= 20; hour++) {
                    mathTutor.addAvailability(day, hour);
                }
            }
            tutorService.update(mathTutor);
            tutors.add(mathTutor);

            // Tutor 2
            Tutor scienceTutor = new Tutor("Prof. Michael Chen", "michael@tutor.com", "password123",
                    65.0, "Master's in Physics, specializing in high school sciences");
            tutorService.register(scienceTutor);

            scienceTutor.addSubject(subjectService.findByName("Physics"));
            scienceTutor.addSubject(subjectService.findByName("Chemistry"));

            for (String day : weekdays) {
                for (int hour = 17; hour <= 21; hour++) {
                    scienceTutor.addAvailability(day, hour);
                }
            }
            for (int hour = 10; hour <= 18; hour++) {
                scienceTutor.addAvailability("Saturday", hour);
                scienceTutor.addAvailability("Sunday", hour);
            }
            tutorService.update(scienceTutor);
            tutors.add(scienceTutor);

            // Tutor 3
            Tutor languageTutor = new Tutor("Maria Rodriguez", "maria@tutor.com", "password123",
                    55.0, "Native Spanish speaker, certified ESL instructor");
            tutorService.register(languageTutor);

            languageTutor.addSubject(subjectService.findByName("English"));
            languageTutor.addSubject(subjectService.findByName("Spanish"));
            languageTutor.addSubject(subjectService.findByName("French"));

            for (String day : weekdays) {
                for (int hour = 8; hour <= 14; hour++) {
                    languageTutor.addAvailability(day, hour);
                }
            }
            tutorService.update(languageTutor);
            tutors.add(languageTutor);

            // Tutor 4
            Tutor codingTutor = new Tutor("Alex Kumar", "alex@tutor.com", "password123",
                    85.0, "Senior Software Engineer, 10+ years industry experience");
            tutorService.register(codingTutor);

            codingTutor.addSubject(subjectService.findByName("Java"));
            codingTutor.addSubject(subjectService.findByName("Python"));
            codingTutor.addSubject(subjectService.findByName("JavaScript"));

            String[] allDays = { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" };
            for (String day : allDays) {
                for (int hour = 18; hour <= 22; hour++) {
                    codingTutor.addAvailability(day, hour);
                }
            }
            tutorService.update(codingTutor);
            tutors.add(codingTutor);

            System.out.println("Tutors initialized: " + tutors.size() + " tutors created");
        } catch (Exception e) {
            System.err.println("Error initializing tutors: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void initializeStudents(StudentService studentService) {
        try {
            // Student 1
            Student student1 = new Student("Emma Wilson", "emma@student.com", "password123");
            studentService.register(student1);
            student1.addFunds(500.0);
            studentService.update(student1);
            students.add(student1);

            // Student 2
            Student student2 = new Student("James Brown", "james@student.com", "password123");
            studentService.register(student2);
            student2.addFunds(750.0);
            studentService.update(student2);
            students.add(student2);

            // Student 3
            Student student3 = new Student("Linda Davis", "linda@student.com", "password123");
            studentService.register(student3);
            student3.addFunds(1000.0);
            studentService.update(student3);
            students.add(student3);

            System.out.println("Students initialized: " + students.size() + " students created");
        } catch (Exception e) {
            System.err.println("Error initializing students: " + e.getMessage());
        }
    }

    public static void initializeBookings(BookingService bookingService, PaymentService paymentService,
            SubjectService subjectService) {
        try {
            if (students.isEmpty() || tutors.isEmpty()) {
                System.err.println("Cannot create bookings: No students or tutors available");
                return;
            }

            // Booking 1
            LocalDateTime pastDate = LocalDateTime.now().minusDays(5).withHour(15).withMinute(0);
            Booking booking1 = bookingService.createBooking(
                    students.get(0).getId(),
                    tutors.get(0).getId(),
                    subjectService.findByName("Calculus"),
                    pastDate,
                    2);

            Payment payment1 = paymentService.processPayment(students.get(0).getId(),
                    booking1.getId(),
                    booking1.getTotalCost());
            bookingService.confirmBooking(booking1.getId(), payment1);
            bookingService.completeBooking(booking1.getId());

            // Booking 2
            LocalDateTime futureDate = LocalDateTime.now().plusDays(3).withHour(18).withMinute(0);
            Booking booking2 = bookingService.createBooking(
                    students.get(1).getId(),
                    tutors.get(3).getId(),
                    subjectService.findByName("Python"),
                    futureDate,
                    1);

            Payment payment2 = paymentService.processPayment(students.get(1).getId(),
                    booking2.getId(),
                    booking2.getTotalCost());
            bookingService.confirmBooking(booking2.getId(), payment2);

            System.out.println("Bookings initialized: Created bookings in various states");
        } catch (Exception e) {
            System.err.println("Error initializing bookings: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void initializeReviews(ReviewService reviewService, BookingService bookingService) {
        try {
            List<Booking> allBookings = new ArrayList<>();
            for (Student student : students) {
                allBookings.addAll(bookingService.findByStudent(student.getId()));
            }

            for (Booking booking : allBookings) {
                if (booking.getStatus() == Booking.BookingStatus.COMPLETED) {
                    if (booking.getStudentId().equals(students.get(0).getId())) {
                        reviewService.createReview(booking.getId(), 5,
                                "Excellent tutor! Very patient and explains concepts clearly. Highly recommended!");
                    }
                }
            }

            System.out.println("Reviews initialized for completed bookings");
        } catch (Exception e) {
            System.err.println("Error initializing reviews: " + e.getMessage());
        }
    }

    public static void initializeAllData(SubjectService subjectService, TutorService tutorService,
            StudentService studentService, BookingService bookingService,
            PaymentService paymentService, ReviewService reviewService) {
        System.out.println("\nStarting Data Initialization");

        initializeSubjects(subjectService);
        initializeTutors(tutorService, subjectService);
        initializeStudents(studentService);
        initializeBookings(bookingService, paymentService, subjectService);
        initializeReviews(reviewService, bookingService);

        System.out.println("\nData Initialization Complete");
        System.out.println("\nTest Accounts:");
        System.out.println("Students: emma@student.com, james@student.com, linda@student.com");
        System.out.println("Tutors: sarah@tutor.com, michael@tutor.com, maria@tutor.com, alex@tutor.com");
        System.out.println("Password for all: password123\n");
    }
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\TestSuiteRunner.java
======================================================================

package com.tutoringplatform;

import org.junit.platform.suite.api.SelectPackages;
import org.junit.platform.suite.api.Suite;
import org.junit.platform.suite.api.SuiteDisplayName;

@Suite
@SuiteDisplayName("Tutoring Platform Test Suite")
@SelectPackages({
        "com.tutoringplatform.command",
        "com.tutoringplatform.controllers",
        "com.tutoringplatform.models",
        "com.tutoringplatform.observer",
        "com.tutoringplatform.repositories.impl",
        "com.tutoringplatform.services"
})
public class TestSuiteRunner {
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\services\AuthServiceTest.java
======================================================================

package com.tutoringplatform.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthServiceTest {

    @Mock
    private IStudentRepository studentRepository;

    @Mock
    private ITutorRepository tutorRepository;

    private AuthService authService;

    @BeforeEach
    void setUp() {
        authService = new AuthService();

        ReflectionTestUtils.setField(authService, "studentRepository", studentRepository);
        ReflectionTestUtils.setField(authService, "tutorRepository", tutorRepository);
    }

    @Test
    @DisplayName("Should login student successfully")
    void testLoginStudent() throws Exception {
        Student student = new Student("John Doe", "john@student.com", "password123");
        when(studentRepository.findByEmail("john@student.com")).thenReturn(student);

        User loggedInUser = authService.login("john@student.com", "password123");

        assertNotNull(loggedInUser);
        assertEquals("John Doe", loggedInUser.getName());
        assertEquals(User.UserType.STUDENT, loggedInUser.getUserType());
    }

    @Test
    @DisplayName("Should login tutor successfully")
    void testLoginTutor() throws Exception {
        Tutor tutor = new Tutor("Jane Smith", "jane@tutor.com", "password123", 50.0, "Math tutor");
        when(studentRepository.findByEmail("jane@tutor.com")).thenReturn(null);
        when(tutorRepository.findByEmail("jane@tutor.com")).thenReturn(tutor);

        User loggedInUser = authService.login("jane@tutor.com", "password123");

        assertNotNull(loggedInUser);
        assertEquals("Jane Smith", loggedInUser.getName());
        assertEquals(User.UserType.TUTOR, loggedInUser.getUserType());
    }

    @Test
    @DisplayName("Should throw exception for invalid email")
    void testLoginInvalidEmail() {
        when(studentRepository.findByEmail("invalid@email.com")).thenReturn(null);
        when(tutorRepository.findByEmail("invalid@email.com")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            authService.login("invalid@email.com", "password");
        }, "Invalid email or password");
    }

    @Test
    @DisplayName("Should throw exception for invalid password")
    void testLoginInvalidPassword() {
        Student student = new Student("John Doe", "john@student.com", "correctpassword");
        when(studentRepository.findByEmail("john@student.com")).thenReturn(student);

        assertThrows(Exception.class, () -> {
            authService.login("john@student.com", "wrongpassword");
        }, "Invalid email or password");
    }

    @Test
    @DisplayName("Should signup student successfully")
    void testSignupStudent() throws Exception {
        when(studentRepository.findByEmail("new@student.com")).thenReturn(null);
        when(tutorRepository.findByEmail("new@student.com")).thenReturn(null);

        Student newStudent = authService.signupStudent("New Student", "new@student.com", "password123");

        assertNotNull(newStudent);
        assertEquals("New Student", newStudent.getName());
        assertEquals("new@student.com", newStudent.getEmail());
        verify(studentRepository).save(any(Student.class));
    }

    @Test
    @DisplayName("Should throw exception when email already exists for student")
    void testSignupStudentEmailExists() {
        Student existingStudent = new Student("Existing", "existing@email.com", "password");
        when(studentRepository.findByEmail("existing@email.com")).thenReturn(existingStudent);

        assertThrows(Exception.class, () -> {
            authService.signupStudent("New Student", "existing@email.com", "password123");
        }, "Email already exists");
    }

    @Test
    @DisplayName("Should signup tutor successfully")
    void testSignupTutor() throws Exception {
        when(studentRepository.findByEmail("new@tutor.com")).thenReturn(null);
        when(tutorRepository.findByEmail("new@tutor.com")).thenReturn(null);

        Tutor newTutor = authService.signupTutor("New Tutor", "new@tutor.com", "password123",
                75.0, "Experienced tutor");

        assertNotNull(newTutor);
        assertEquals("New Tutor", newTutor.getName());
        assertEquals(75.0, newTutor.getHourlyRate());
        verify(tutorRepository).save(any(Tutor.class));
    }

    @Test
    @DisplayName("Should throw exception for invalid hourly rate")
    void testSignupTutorInvalidRate() {
        when(studentRepository.findByEmail("new@tutor.com")).thenReturn(null);
        when(tutorRepository.findByEmail("new@tutor.com")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            authService.signupTutor("New Tutor", "new@tutor.com", "password123",
                    -10.0, "Description");
        }, "Hourly rate must be positive");
    }

    @Test
    @DisplayName("Should check both repositories for existing email")
    void testSignupChecksBothRepositories() throws Exception {
        Tutor existingTutor = new Tutor("Existing", "existing@email.com", "password", 50.0, "Desc");
        when(studentRepository.findByEmail("existing@email.com")).thenReturn(null);
        when(tutorRepository.findByEmail("existing@email.com")).thenReturn(existingTutor);

        assertThrows(Exception.class, () -> {
            authService.signupStudent("New Student", "existing@email.com", "password123");
        }, "Email already exists");
    }
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\services\BookingServiceTest.java
======================================================================

package com.tutoringplatform.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.tutoringplatform.models.*;
import com.tutoringplatform.observer.*;
import com.tutoringplatform.repositories.interfaces.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.any;

@ExtendWith(MockitoExtension.class)
class BookingServiceTest {

    @Mock
    private IBookingRepository bookingRepository;

    @Mock
    private IStudentRepository studentRepository;

    @Mock
    private ITutorRepository tutorRepository;

    @Mock
    private BookingObserver mockObserver;

    private BookingService bookingService;
    private Student testStudent;
    private Tutor testTutor;
    private Subject testSubject;
    private LocalDateTime bookingTime;

    @BeforeEach
    void setUp() {
        bookingService = new BookingService(bookingRepository, studentRepository, tutorRepository);
        bookingService.addObserver(mockObserver);

        testStudent = new Student("John Doe", "john@student.com", "password123");
        testTutor = new Tutor("Jane Smith", "jane@tutor.com", "password123", 50.0, "Math tutor");
        testSubject = new Subject("Math", "Mathematics");
        bookingTime = LocalDateTime.now().plusDays(1).withHour(15).withMinute(0);

        testTutor.addSubject(testSubject);
        String dayOfWeek = bookingTime.getDayOfWeek().name();
        dayOfWeek = dayOfWeek.substring(0, 1) + dayOfWeek.substring(1).toLowerCase();

        testTutor.addAvailability(dayOfWeek, 15);
        testTutor.addAvailability(dayOfWeek, 16);
    }

    @Test
    @DisplayName("Should create booking successfully")
    void testCreateBooking() throws Exception {
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);
        when(bookingRepository.findByTutorId("tutor456")).thenReturn(new ArrayList<>());

        Booking booking = bookingService.createBooking("student123", "tutor456",
                testSubject, bookingTime, 2);

        assertNotNull(booking);
        assertEquals("student123", booking.getStudentId());
        assertEquals("tutor456", booking.getTutorId());
        assertEquals(100.0, booking.getTotalCost());
        assertEquals(Booking.BookingStatus.PENDING, booking.getStatus());
        verify(bookingRepository).save(any(Booking.class));
        verify(mockObserver).update(any(BookingEvent.class));
    }

    @Test
    @DisplayName("Should throw exception when student not found")
    void testCreateBookingStudentNotFound() {
        when(studentRepository.findById("invalid")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            bookingService.createBooking("invalid", "tutor456", testSubject, bookingTime, 2);
        }, "Student not found");
    }

    @Test
    @DisplayName("Should throw exception when tutor doesn't teach subject")
    void testCreateBookingTutorDoesntTeachSubject() {
        Subject otherSubject = new Subject("Physics", "Science");
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);

        assertThrows(Exception.class, () -> {
            bookingService.createBooking("student123", "tutor456",
                    otherSubject, bookingTime, 2);
        }, "Tutor does not teach this subject");
    }

    @Test
    @DisplayName("Should throw exception when tutor not available")
    void testCreateBookingTutorNotAvailable() {
        LocalDateTime unavailableTime = LocalDateTime.now().plusDays(1).withHour(20).withMinute(0);
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);

        assertThrows(Exception.class, () -> {
            bookingService.createBooking("student123", "tutor456",
                    testSubject, unavailableTime, 2);
        }, "Tutor is not available at this time");
    }

    @Test
    @DisplayName("Should throw exception for time conflict")
    void testCreateBookingTimeConflict() throws Exception {
        Booking existingBooking = new Booking("student999", "tutor456", testSubject,
                bookingTime, 2, 50.0);
        existingBooking.setStatus(Booking.BookingStatus.CONFIRMED);

        when(studentRepository.findById("student123")).thenReturn(testStudent);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);
        when(bookingRepository.findByTutorId("tutor456")).thenReturn(Arrays.asList(existingBooking));

        assertThrows(Exception.class, () -> {
            bookingService.createBooking("student123", "tutor456",
                    testSubject, bookingTime.plusMinutes(30), 1);
        }, "Time slot already booked");
    }

    @Test
    @DisplayName("Should confirm booking successfully")
    void testConfirmBooking() throws Exception {
        Booking booking = new Booking("student123", "tutor456", testSubject,
                bookingTime, 2, 50.0);
        Payment payment = new Payment(booking.getId(), 100.0);
        payment.setStatus(Payment.PaymentStatus.COMPLETED);

        when(bookingRepository.findById(booking.getId())).thenReturn(booking);
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);

        bookingService.confirmBooking(booking.getId(), payment);

        assertEquals(Booking.BookingStatus.CONFIRMED, booking.getStatus());
        assertEquals(payment, booking.getPayment());
        assertTrue(testStudent.getBookings().contains(booking));
        assertTrue(testTutor.getBookings().contains(booking));
        verify(bookingRepository).update(booking);
        verify(studentRepository).update(testStudent);
        verify(tutorRepository).update(testTutor);
        verify(mockObserver).update(any(BookingEvent.class));
    }

    @Test
    @DisplayName("Should cancel booking successfully")
    void testCancelBooking() throws Exception {
        Booking booking = new Booking("student123", "tutor456", testSubject,
                bookingTime, 2, 50.0);
        booking.setStatus(Booking.BookingStatus.CONFIRMED);

        when(bookingRepository.findById(booking.getId())).thenReturn(booking);
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);

        bookingService.cancelBooking(booking.getId());

        assertEquals(Booking.BookingStatus.CANCELLED, booking.getStatus());
        verify(bookingRepository).update(booking);
        verify(mockObserver).update(any(BookingEvent.class));
    }

    @Test
    @DisplayName("Should not cancel completed booking")
    void testCancelCompletedBooking() {
        Booking booking = new Booking("student123", "tutor456", testSubject,
                bookingTime, 2, 50.0);
        booking.setStatus(Booking.BookingStatus.COMPLETED);

        when(bookingRepository.findById(booking.getId())).thenReturn(booking);

        assertThrows(Exception.class, () -> {
            bookingService.cancelBooking(booking.getId());
        }, "Cannot cancel completed booking");
    }

    @Test
    @DisplayName("Should complete booking successfully")
    void testCompleteBooking() throws Exception {
        Booking booking = new Booking("student123", "tutor456", testSubject,
                bookingTime, 2, 50.0);
        booking.setStatus(Booking.BookingStatus.CONFIRMED);

        when(bookingRepository.findById(booking.getId())).thenReturn(booking);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        bookingService.completeBooking(booking.getId());

        assertEquals(Booking.BookingStatus.COMPLETED, booking.getStatus());
        assertEquals(100.0, testTutor.getEarnings());
        verify(bookingRepository).update(booking);
        verify(tutorRepository).update(testTutor);
        verify(mockObserver).update(any(BookingEvent.class));
    }

    @Test
    @DisplayName("Should find bookings by student")
    void testFindByStudent() {
        List<Booking> expectedBookings = Arrays.asList(
                new Booking("student123", "tutor1", testSubject, bookingTime, 1, 50.0),
                new Booking("student123", "tutor2", testSubject, bookingTime.plusDays(1), 2, 60.0));
        when(bookingRepository.findByStudentId("student123")).thenReturn(expectedBookings);

        List<Booking> result = bookingService.findByStudent("student123");

        assertEquals(2, result.size());
        assertTrue(result.stream().allMatch(b -> b.getStudentId().equals("student123")));
    }
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\services\PaymentServiceTest.java
======================================================================

package com.tutoringplatform.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;
import java.util.Stack;

import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.any;

@ExtendWith(MockitoExtension.class)
class PaymentServiceTest {

    @Mock
    private IPaymentRepository paymentRepository;

    @Mock
    private IStudentRepository studentRepository;

    @Mock
    private IBookingRepository bookingRepository;

    private PaymentService paymentService;
    private Student testStudent;
    private Booking testBooking;

    @BeforeEach
    void setUp() {
        paymentService = new PaymentService();

        ReflectionTestUtils.setField(paymentService, "paymentRepository", paymentRepository);
        ReflectionTestUtils.setField(paymentService, "studentRepository", studentRepository);
        ReflectionTestUtils.setField(paymentService, "bookingRepository", bookingRepository);

        ReflectionTestUtils.setField(paymentService, "commandHistory", new Stack<IPaymentCommand>());

        testStudent = new Student("John Doe", "john@student.com", "password123");
        testStudent.setBalance(200.0);

        Subject subject = new Subject("Math", "Mathematics");
        testBooking = new Booking("student123", "tutor456", subject,
                LocalDateTime.now().plusDays(1), 2, 50.0);
    }

    @Test
    @DisplayName("Should process payment successfully")
    void testProcessPayment() throws Exception {
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        Payment payment = paymentService.processPayment("student123", "booking123", 100.0);

        assertNotNull(payment);
        assertEquals(100.0, payment.getAmount());
        assertEquals("booking123", payment.getBookingId());
        assertEquals(Payment.PaymentStatus.COMPLETED, payment.getStatus());
        assertEquals(100.0, testStudent.getBalance());
        verify(paymentRepository).save(any(Payment.class));
        verify(studentRepository).update(testStudent);
    }

    @Test
    @DisplayName("Should throw exception when student not found")
    void testProcessPaymentStudentNotFound() {
        when(studentRepository.findById("invalid")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            paymentService.processPayment("invalid", "booking123", 100.0);
        }, "Student not found");
    }

    @Test
    @DisplayName("Should throw exception for insufficient funds")
    void testProcessPaymentInsufficientFunds() {
        testStudent.setBalance(50.0);
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        assertThrows(Exception.class, () -> {
            paymentService.processPayment("student123", "booking123", 100.0);
        }, "Insufficient funds");
    }

    @Test
    @DisplayName("Should refund payment successfully")
    void testRefundPayment() throws Exception {
        Payment payment = new Payment("booking123", 100.0);
        payment.setStatus(Payment.PaymentStatus.COMPLETED);

        when(paymentRepository.findById("payment123")).thenReturn(payment);
        when(bookingRepository.findById("booking123")).thenReturn(testBooking);
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        testStudent.setBalance(100.0);

        paymentService.refundPayment("payment123");

        assertEquals(Payment.PaymentStatus.REFUNDED, payment.getStatus());
        assertEquals(200.0, testStudent.getBalance());
        verify(paymentRepository).update(payment);
        verify(studentRepository).update(testStudent);
    }

    @Test
    @DisplayName("Should not refund non-completed payment")
    void testRefundNonCompletedPayment() {
        Payment payment = new Payment("booking123", 100.0);
        payment.setStatus(Payment.PaymentStatus.PENDING);

        when(paymentRepository.findById("payment123")).thenReturn(payment);
        when(bookingRepository.findById("booking123")).thenReturn(testBooking);
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        assertThrows(Exception.class, () -> {
            paymentService.refundPayment("payment123");
        }, "Can only refund completed payments");
    }

    @Test
    @DisplayName("Should undo last payment action")
    void testUndoLastPaymentAction() throws Exception {
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        Payment payment = paymentService.processPayment("student123", "booking123", 100.0);
        assertEquals(100.0, testStudent.getBalance());

        paymentService.undoLastPaymentAction();

        assertEquals(200.0, testStudent.getBalance());
        assertEquals(Payment.PaymentStatus.REFUNDED, payment.getStatus());
        verify(paymentRepository, times(1)).save(payment);
        verify(paymentRepository, times(1)).update(payment);
        verify(studentRepository, times(2)).update(testStudent);
    }

    @Test
    @DisplayName("Should throw exception when no action to undo")
    void testUndoWithEmptyHistory() {
        assertThrows(Exception.class, () -> {
            paymentService.undoLastPaymentAction();
        }, "No payment action to undo");
    }

    @Test
    @DisplayName("Should find payment by ID")
    void testFindById() throws Exception {
        Payment payment = new Payment("booking123", 100.0);
        when(paymentRepository.findById("payment123")).thenReturn(payment);

        Payment found = paymentService.findById("payment123");

        assertNotNull(found);
        assertEquals("booking123", found.getBookingId());
        assertEquals(100.0, found.getAmount());
    }

    @Test
    @DisplayName("Should throw exception when payment not found")
    void testFindByIdNotFound() {
        when(paymentRepository.findById("invalid")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            paymentService.findById("invalid");
        }, "Payment not found");
    }

    @Test
    @DisplayName("Should handle multiple undo operations")
    void testMultipleUndoOperations() throws Exception {
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        Payment payment1 = paymentService.processPayment("student123", "booking1", 50.0);
        assertEquals(150.0, testStudent.getBalance());

        Payment payment2 = paymentService.processPayment("student123", "booking2", 30.0);
        assertEquals(120.0, testStudent.getBalance());

        paymentService.undoLastPaymentAction();
        assertEquals(150.0, testStudent.getBalance());

        paymentService.undoLastPaymentAction();
        assertEquals(200.0, testStudent.getBalance());

        assertEquals(Payment.PaymentStatus.REFUNDED, payment1.getStatus());
        assertEquals(Payment.PaymentStatus.REFUNDED, payment2.getStatus());
    }
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\services\ReviewServiceTest.java
======================================================================

package com.tutoringplatform.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.any;

@ExtendWith(MockitoExtension.class)
class ReviewServiceTest {

    @Mock
    private IReviewRepository reviewRepository;

    @Mock
    private IBookingRepository bookingRepository;

    @Mock
    private ITutorRepository tutorRepository;

    @Mock
    private IStudentRepository studentRepository;

    private ReviewService reviewService;
    private Booking completedBooking;
    private Student testStudent;
    private Tutor testTutor;

    @BeforeEach
    void setUp() {
        reviewService = new ReviewService();
        ReflectionTestUtils.setField(reviewService, "reviewRepository", reviewRepository);
        ReflectionTestUtils.setField(reviewService, "bookingRepository", bookingRepository);
        ReflectionTestUtils.setField(reviewService, "tutorRepository", tutorRepository);
        ReflectionTestUtils.setField(reviewService, "studentRepository", studentRepository);

        Subject subject = new Subject("Math", "Mathematics");
        completedBooking = new Booking("student123", "tutor456", subject,
                LocalDateTime.now().minusDays(1), 2, 50.0);
        completedBooking.setStatus(Booking.BookingStatus.COMPLETED);

        testStudent = new Student("John Doe", "john@student.com", "password123");
        testTutor = new Tutor("Jane Smith", "jane@tutor.com", "password123", 50.0, "Math tutor");
    }

    @Test
    @DisplayName("Should create review successfully")
    void testCreateReview() throws Exception {
        when(bookingRepository.findById("booking123")).thenReturn(completedBooking);
        when(reviewRepository.findByBookingId("booking123")).thenReturn(null);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        Review review = reviewService.createReview("booking123", 5, "Excellent tutor!");

        assertNotNull(review);
        assertEquals(5, review.getRating());
        assertEquals("Excellent tutor!", review.getComment());
        assertEquals("student123", review.getStudentId());
        assertEquals("tutor456", review.getTutorId());
        verify(reviewRepository).save(any(Review.class));
        verify(tutorRepository).update(testTutor);
        verify(studentRepository).update(testStudent);
        assertTrue(testTutor.getReviewsReceived().contains(review));
        assertTrue(testStudent.getReviewsGiven().contains(review));
    }

    @Test
    @DisplayName("Should throw exception when booking not found")
    void testCreateReviewBookingNotFound() {
        when(bookingRepository.findById("invalid")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            reviewService.createReview("invalid", 5, "Good");
        }, "Booking not found");
    }

    @Test
    @DisplayName("Should throw exception for non-completed booking")
    void testCreateReviewBookingNotCompleted() {
        Booking pendingBooking = new Booking("student123", "tutor456",
                new Subject("Math", "Mathematics"),
                LocalDateTime.now().plusDays(1), 2, 50.0);
        pendingBooking.setStatus(Booking.BookingStatus.PENDING);

        when(bookingRepository.findById("booking123")).thenReturn(pendingBooking);

        assertThrows(Exception.class, () -> {
            reviewService.createReview("booking123", 5, "Good");
        }, "Can only review completed bookings");
    }

    @Test
    @DisplayName("Should throw exception when review already exists")
    void testCreateReviewAlreadyExists() {
        Review existingReview = new Review("student123", "tutor456", "booking123", 4, "Good");

        when(bookingRepository.findById("booking123")).thenReturn(completedBooking);
        when(reviewRepository.findByBookingId("booking123")).thenReturn(existingReview);

        assertThrows(Exception.class, () -> {
            reviewService.createReview("booking123", 5, "Excellent!");
        }, "Review already exists for this booking");
    }

    @Test
    @DisplayName("Should validate rating range")
    void testCreateReviewInvalidRating() {
        when(bookingRepository.findById("booking123")).thenReturn(completedBooking);
        when(reviewRepository.findByBookingId("booking123")).thenReturn(null);

        assertThrows(IllegalArgumentException.class, () -> {
            reviewService.createReview("booking123", 6, "Too high rating");
        }, "Rating must be between 1 and 5");

        assertThrows(IllegalArgumentException.class, () -> {
            reviewService.createReview("booking123", 0, "Too low rating");
        }, "Rating must be between 1 and 5");
    }

    @Test
    @DisplayName("Should find reviews by tutor")
    void testFindByTutor() {
        List<Review> tutorReviews = Arrays.asList(
                new Review("student1", "tutor456", "booking1", 5, "Excellent!"),
                new Review("student2", "tutor456", "booking2", 4, "Very good"));

        when(reviewRepository.findByTutorId("tutor456")).thenReturn(tutorReviews);

        List<Review> result = reviewService.findByTutor("tutor456");

        assertEquals(2, result.size());
        assertTrue(result.stream().allMatch(r -> r.getTutorId().equals("tutor456")));
    }

    @Test
    @DisplayName("Should find reviews by student")
    void testFindByStudent() {
        List<Review> studentReviews = Arrays.asList(
                new Review("student123", "tutor1", "booking1", 5, "Great!"),
                new Review("student123", "tutor2", "booking2", 3, "Average"));

        when(reviewRepository.findByStudentId("student123")).thenReturn(studentReviews);

        List<Review> result = reviewService.findByStudent("student123");

        assertEquals(2, result.size());
        assertTrue(result.stream().allMatch(r -> r.getStudentId().equals("student123")));
    }

    @Test
    @DisplayName("Should calculate correct average rating for tutor")
    void testTutorAverageRating() throws Exception {
        when(bookingRepository.findById("booking123")).thenReturn(completedBooking);
        when(reviewRepository.findByBookingId("booking123")).thenReturn(null);
        when(tutorRepository.findById("tutor456")).thenReturn(testTutor);
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        Review review1 = new Review("student1", "tutor456", "booking1", 5, "Excellent!");
        Review review2 = new Review("student2", "tutor456", "booking2", 4, "Good");
        testTutor.addReview(review1);
        testTutor.addReview(review2);

        reviewService.createReview("booking123", 3, "Average");

        assertEquals(3, testTutor.getReviewsReceived().size());
        assertEquals(4.0, testTutor.getAverageRating());
    }
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\services\StudentServiceTest.java
======================================================================

package com.tutoringplatform.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class StudentServiceTest {

    @Mock
    private IStudentRepository studentRepository;

    private StudentService studentService;
    private Student testStudent;

    @BeforeEach
    void setUp() {
        studentService = new StudentService(studentRepository);
        testStudent = new Student("John Doe", "john@student.com", "password123");
    }

    @Test
    @DisplayName("Should register new student successfully")
    void testRegisterStudent() throws Exception {
        when(studentRepository.findByEmail("john@student.com")).thenReturn(null);

        studentService.register(testStudent);

        verify(studentRepository).save(testStudent);
    }

    @Test
    @DisplayName("Should throw exception when email already exists")
    void testRegisterStudentEmailExists() {
        when(studentRepository.findByEmail("john@student.com")).thenReturn(testStudent);

        Student newStudent = new Student("Another John", "john@student.com", "password");
        assertThrows(Exception.class, () -> {
            studentService.register(newStudent);
        }, "Email already exists");
    }

    @Test
    @DisplayName("Should add funds successfully")
    void testAddFunds() throws Exception {
        when(studentRepository.findById("student123")).thenReturn(testStudent);
        double initialBalance = testStudent.getBalance();

        studentService.addFunds("student123", 100.50);

        assertEquals(initialBalance + 100.50, testStudent.getBalance());
        verify(studentRepository).update(testStudent);
    }

    @Test
    @DisplayName("Should throw exception for negative amount")
    void testAddFundsNegativeAmount() {
        assertThrows(Exception.class, () -> {
            studentService.addFunds("student123", -50.0);
        }, "Amount must be positive");
    }

    @Test
    @DisplayName("Should throw exception for zero amount")
    void testAddFundsZeroAmount() {
        assertThrows(Exception.class, () -> {
            studentService.addFunds("student123", 0.0);
        }, "Amount must be positive");
    }

    @Test
    @DisplayName("Should throw exception when student not found for add funds")
    void testAddFundsStudentNotFound() {
        when(studentRepository.findById("nonexistent")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            studentService.addFunds("nonexistent", 100.0);
        }, "User not found with id: nonexistent");
    }

    @Test
    @DisplayName("Should search students by name")
    void testSearchByName() {
        Student student1 = new Student("John Doe", "john1@test.com", "pass");
        Student student2 = new Student("John Smith", "john2@test.com", "pass");
        List<Student> expectedStudents = Arrays.asList(student1, student2);

        when(studentRepository.findByNameContaining("John")).thenReturn(expectedStudents);

        List<Student> result = studentService.searchByName("John");

        assertEquals(2, result.size());
        assertTrue(result.stream().allMatch(s -> s.getName().contains("John")));
    }

    @Test
    @DisplayName("Should find student by ID")
    void testFindById() throws Exception {
        when(studentRepository.findById("student123")).thenReturn(testStudent);

        Student found = studentService.findById("student123");

        assertNotNull(found);
        assertEquals(testStudent.getId(), found.getId());
    }

    @Test
    @DisplayName("Should throw exception when student not found by ID")
    void testFindByIdNotFound() {
        when(studentRepository.findById("nonexistent")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            studentService.findById("nonexistent");
        }, "User not found with id: nonexistent");
    }

    @Test
    @DisplayName("Should update student")
    void testUpdateStudent() throws Exception {
        when(studentRepository.findById(testStudent.getId())).thenReturn(testStudent);
        testStudent.setName("Updated Name");

        studentService.update(testStudent);

        verify(studentRepository).update(testStudent);
    }

    @Test
    @DisplayName("Should throw exception when updating non-existent student")
    void testUpdateNonExistentStudent() {
        when(studentRepository.findById(testStudent.getId())).thenReturn(null);

        assertThrows(Exception.class, () -> {
            studentService.update(testStudent);
        }, "User not found");
    }
}



======================================================================
// FILE: src\test\java\com\tutoringplatform\services\TutorServiceTest.java
======================================================================

package com.tutoringplatform.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.tutoringplatform.models.Review;
import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TutorServiceTest {

    @Mock
    private ITutorRepository tutorRepository;

    private TutorService tutorService;
    private Tutor testTutor;

    @BeforeEach
    void setUp() {
        tutorService = new TutorService(tutorRepository);
        testTutor = new Tutor("Jane Smith", "jane@tutor.com", "password123",
                50.0, "Experienced math tutor");
    }

    @Test
    @DisplayName("Should register new tutor successfully")
    void testRegisterTutor() throws Exception {
        when(tutorRepository.findByEmail("jane@tutor.com")).thenReturn(null);

        tutorService.register(testTutor);

        verify(tutorRepository).save(testTutor);
    }

    @Test
    @DisplayName("Should throw exception when email already exists")
    void testRegisterTutorEmailExists() {
        when(tutorRepository.findByEmail("jane@tutor.com")).thenReturn(testTutor);

        Tutor newTutor = new Tutor("Another Jane", "jane@tutor.com", "password", 60.0, "Description");
        assertThrows(Exception.class, () -> {
            tutorService.register(newTutor);
        }, "Email already exists");
    }

    @Test
    @DisplayName("Should throw exception for invalid hourly rate")
    void testRegisterTutorInvalidRate() {
        Tutor invalidTutor = new Tutor("Bob", "bob@tutor.com", "password", -10.0, "Description");
        when(tutorRepository.findByEmail("bob@tutor.com")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            tutorService.register(invalidTutor);
        }, "Hourly rate must be positive");
    }

    @Test
    @DisplayName("Should search tutors by subject")
    void testSearchTutorsBySubject() {
        Subject mathSubject = new Subject("Math", "Mathematics");
        testTutor.addSubject(mathSubject);

        Tutor tutor2 = new Tutor("Bob Wilson", "bob@tutor.com", "password", 60.0, "Physics tutor");
        Subject physicsSubject = new Subject("Physics", "Science");
        tutor2.addSubject(physicsSubject);

        List<Tutor> allTutors = Arrays.asList(testTutor, tutor2);
        when(tutorRepository.findAll()).thenReturn(allTutors);

        List<Tutor> mathTutors = tutorService.searchTutors(mathSubject, null, null, null, null, null);

        assertEquals(1, mathTutors.size());
        assertEquals("Jane Smith", mathTutors.get(0).getName());
    }

    @Test
    @DisplayName("Should search tutors by price range")
    void testSearchTutorsByPriceRange() {
        Tutor tutor2 = new Tutor("Bob", "bob@tutor.com", "password", 75.0, "Senior tutor");
        Tutor tutor3 = new Tutor("Alice", "alice@tutor.com", "password", 30.0, "Junior tutor");

        List<Tutor> allTutors = Arrays.asList(testTutor, tutor2, tutor3); // 50, 75, 30
        when(tutorRepository.findAll()).thenReturn(allTutors);

        List<Tutor> midRangeTutors = tutorService.searchTutors(null, 40.0, 60.0, null, null, null);

        assertEquals(1, midRangeTutors.size());
        assertEquals(50.0, midRangeTutors.get(0).getHourlyRate());
    }

    @Test
    @DisplayName("Should search tutors by minimum rating")
    void testSearchTutorsByRating() {
        testTutor.addReview(
                new Review("student1", testTutor.getId(), "booking1", 5, "Excellent"));
        testTutor.addReview(
                new Review("student2", testTutor.getId(), "booking2", 4, "Good"));

        Tutor lowRatedTutor = new Tutor("Bob", "bob@tutor.com", "password", 40.0, "New tutor");
        lowRatedTutor.addReview(
                new Review("student3", lowRatedTutor.getId(), "booking3", 2, "Poor"));

        List<Tutor> allTutors = Arrays.asList(testTutor, lowRatedTutor);
        when(tutorRepository.findAll()).thenReturn(allTutors);

        List<Tutor> highRatedTutors = tutorService.searchTutors(null, null, null, 4.0, null, null);

        assertEquals(1, highRatedTutors.size());
        assertEquals(4.5, highRatedTutors.get(0).getAverageRating());
    }

    @Test
    @DisplayName("Should search tutors by availability")
    void testSearchTutorsByAvailability() {
        testTutor.addAvailability("Monday", 14);
        testTutor.addAvailability("Monday", 15);

        Tutor tutor2 = new Tutor("Bob", "bob@tutor.com", "password", 60.0, "Evening tutor");
        tutor2.addAvailability("Monday", 18);
        tutor2.addAvailability("Monday", 19);

        List<Tutor> allTutors = Arrays.asList(testTutor, tutor2);
        when(tutorRepository.findAll()).thenReturn(allTutors);

        List<Tutor> afternoonTutors = tutorService.searchTutors(null, null, null, null, "Monday", 14);

        assertEquals(1, afternoonTutors.size());
        assertEquals("Jane Smith", afternoonTutors.get(0).getName());
    }

    @Test
    @DisplayName("Should combine multiple search filters")
    void testSearchTutorsMultipleFilters() {
        Subject mathSubject = new Subject("Math", "Mathematics");
        testTutor.addSubject(mathSubject);
        testTutor.addAvailability("Monday", 14);

        Tutor tutor2 = new Tutor("Bob", "bob@tutor.com", "password", 100.0, "Expensive tutor");
        tutor2.addSubject(mathSubject);
        tutor2.addAvailability("Monday", 14);

        List<Tutor> allTutors = Arrays.asList(testTutor, tutor2);
        when(tutorRepository.findAll()).thenReturn(allTutors);

        List<Tutor> filteredTutors = tutorService.searchTutors(mathSubject, null, 60.0, null, "Monday", 14);

        assertEquals(1, filteredTutors.size());
        assertEquals("Jane Smith", filteredTutors.get(0).getName());
    }

    @Test
    @DisplayName("Should update availability successfully")
    void testUpdateAvailability() throws Exception {
        when(tutorRepository.findById("tutor123")).thenReturn(testTutor);

        tutorService.updateAvailability("tutor123", "Monday", 14, true);

        assertTrue(testTutor.isAvailable("Monday", 14));
        verify(tutorRepository).update(testTutor);

        tutorService.updateAvailability("tutor123", "Monday", 14, false);

        assertFalse(testTutor.isAvailable("Monday", 14));
        verify(tutorRepository, times(2)).update(testTutor);
    }

    @Test
    @DisplayName("Should throw exception when tutor not found for update")
    void testUpdateAvailabilityTutorNotFound() {
        when(tutorRepository.findById("invalid")).thenReturn(null);

        assertThrows(Exception.class, () -> {
            tutorService.updateAvailability("invalid", "Monday", 14, true);
        }, "User not found with id: invalid");
    }

    @Test
    @DisplayName("Should find tutor by ID")
    void testFindById() throws Exception {
        when(tutorRepository.findById("tutor123")).thenReturn(testTutor);

        Tutor found = tutorService.findById("tutor123");

        assertNotNull(found);
        assertEquals(testTutor.getId(), found.getId());
    }

    @Test
    @DisplayName("Should return empty list when no tutors match criteria")
    void testSearchNoMatches() {
        when(tutorRepository.findAll()).thenReturn(Arrays.asList(testTutor));

        List<Tutor> expensiveTutors = tutorService.searchTutors(null, 100.0, null, null, null, null);

        assertTrue(expensiveTutors.isEmpty());
    }
}



