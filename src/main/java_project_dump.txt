======================================================================
// FILE: java\com\tutoringplatform\TutoringPlatformApplication.java
======================================================================

package com.tutoringplatform;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;


@SpringBootApplication(exclude = {
        DataSourceAutoConfiguration.class,
        HibernateJpaAutoConfiguration.class
})
public class TutoringPlatformApplication {

    public static void main(String[] args) {
        SpringApplication.run(TutoringPlatformApplication.class, args);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\command\ProcessPaymentCommand.java
======================================================================

package com.tutoringplatform.command;

import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IPaymentCommand;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;

public class ProcessPaymentCommand implements IPaymentCommand {
    private Payment payment;
    private Student student;
    private double amount;
    private IPaymentRepository paymentRepository;
    private IStudentRepository studentRepository;

    public ProcessPaymentCommand(Payment payment, Student student, double amount, IPaymentRepository paymentRepository, IStudentRepository studentRepository) {
        this.payment = payment;
        this.student = student;
        this.amount = amount;
        this.paymentRepository = paymentRepository;
        this.studentRepository = studentRepository;
    }

    @Override
    public void execute() throws Exception {
        Student student = studentRepository.findById(this.student.getId());
        student.setBalance(student.getBalance() - amount);
        payment.setStatus(Payment.PaymentStatus.COMPLETED);
        paymentRepository.save(payment);
        studentRepository.update(student);
    }

    @Override
    public void undo() throws Exception {
        student.setBalance(student.getBalance() + amount);
        payment.setStatus(Payment.PaymentStatus.REFUNDED);
        paymentRepository.update(payment);
        studentRepository.update(student);
    }

    @Override
    public Payment getPayment() {
        return payment;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\command\RefundPaymentCommand.java
======================================================================

package com.tutoringplatform.command;


import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IPaymentCommand;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;

public class RefundPaymentCommand implements IPaymentCommand {
    private Payment payment;
    private Student student;
    private double amount;
    private IPaymentRepository paymentRepository;
    private IStudentRepository studentRepository;

    public RefundPaymentCommand(Payment payment, Student student, double amount, IPaymentRepository paymentRepository, IStudentRepository studentRepository) {
        this.payment = payment;
        this.student = student;
        this.amount = amount;
        this.paymentRepository = paymentRepository;
        this.studentRepository = studentRepository;
    }

    @Override
    public void execute() throws Exception {
        if (payment.getStatus() != Payment.PaymentStatus.COMPLETED) {
            throw new Exception("Can only refund completed payments");
        }
        student.setBalance(student.getBalance() + amount);
        payment.setStatus(Payment.PaymentStatus.REFUNDED);
        paymentRepository.update(payment);
        studentRepository.update(student);
    }

    @Override
    public void undo() throws Exception {
        student.setBalance(student.getBalance() - amount);
        payment.setStatus(Payment.PaymentStatus.COMPLETED);
        paymentRepository.update(payment);
        studentRepository.update(student);
    }

    @Override
    public Payment getPayment() {
        return payment;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\config\AppProperties.java
======================================================================

package com.tutoringplatform.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private String[] allowedOrigins = {};
    private final Api api = new Api();

    public static class Api {
        private String filesBaseUrl = "/api/files/";

        public String getFilesBaseUrl() {
            return filesBaseUrl;
        }

        public void setFilesBaseUrl(String filesBaseUrl) {
            this.filesBaseUrl = filesBaseUrl;
        }
    }

    // Getters and Setters
    public String[] getAllowedOrigins() {
        return allowedOrigins;
    }

    public void setAllowedOrigins(String[] allowedOrigins) {
        this.allowedOrigins = allowedOrigins;
    }

    public Api getApi() {
        return api;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\config\DataInitializationConfiguration.java
======================================================================

package com.tutoringplatform.config;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

import com.tutoringplatform.services.BookingService;
import com.tutoringplatform.services.PaymentService;
import com.tutoringplatform.services.ReviewService;
import com.tutoringplatform.services.StudentService;
import com.tutoringplatform.services.SubjectService;
import com.tutoringplatform.services.TutorService;
@Configuration
@Profile("!test")
public class DataInitializationConfiguration {

    @Bean
    CommandLineRunner init(SubjectService subjectService, TutorService tutorService, StudentService studentService,
            BookingService bookingService, PaymentService paymentService, ReviewService reviewService) {
        return args -> {
            System.out.println("Application started! Access at http://localhost:8080");
        };
    }
}



======================================================================
// FILE: java\com\tutoringplatform\config\SecurityConfig.java
======================================================================

package com.tutoringplatform.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf().disable() // Disable CSRF for stateless APIs
                .authorizeHttpRequests(auth -> auth
                        .antMatchers("/", "/index.html", "/css/**", "/js/**", "/images/**", "/api/auth/**").permitAll() 
                        .anyRequest().authenticated() // Secure any other endpoint (if any)
                );
        return http.build();
    }
}



======================================================================
// FILE: java\com\tutoringplatform\config\WebConfiguration.java
======================================================================

package com.tutoringplatform.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.lang.NonNull;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfiguration implements WebMvcConfigurer {

    @Autowired
    private AppProperties appProperties;

    @Override
    public void addCorsMappings(@NonNull CorsRegistry registry) {
        registry.addMapping("/api/**") // Apply CORS to all /api endpoints
                .allowedOrigins(appProperties.getAllowedOrigins())
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\AuthenticationController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.request.LoginRequest;
import com.tutoringplatform.dto.request.SignupRequest;
import com.tutoringplatform.dto.response.AuthResponse;
import com.tutoringplatform.services.AuthenticationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/auth")
public class AuthenticationController {

    private final AuthenticationService authenticationService;

    @Autowired
    public AuthenticationController(AuthenticationService authenticationService) {
        this.authenticationService = authenticationService;
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        try {
            AuthResponse response = authenticationService.login(request.getEmail(), request.getPassword());
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(e.getMessage());
        }
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody SignupRequest request) {
        try {
            AuthResponse response = authenticationService.signup(request);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\BookingController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.request.CreateBookingRequest;
import com.tutoringplatform.dto.request.UpdateBookingRequest;
import com.tutoringplatform.dto.response.BookingDetailResponse;
import com.tutoringplatform.dto.response.BookingListResponse;
import com.tutoringplatform.services.BookingService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/bookings")
public class BookingController {

    private final BookingService bookingService;

    @Autowired
    public BookingController(BookingService bookingService) {
        this.bookingService = bookingService;
    }

    @PostMapping
    public ResponseEntity<?> createBooking(@RequestBody CreateBookingRequest request) {
        try {
            BookingDetailResponse booking = bookingService.createBooking(request);
            return ResponseEntity.status(HttpStatus.CREATED).body(booking);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getBooking(@PathVariable String id) {
        try {
            BookingDetailResponse booking = bookingService.getBookingDetails(id);
            return ResponseEntity.ok(booking);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/student/{studentId}")
    public ResponseEntity<?> getStudentBookings(@PathVariable String studentId) {
        try {
            BookingListResponse bookings = bookingService.getStudentBookingList(studentId);
            return ResponseEntity.ok(bookings);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/tutor/{tutorId}")
    public ResponseEntity<?> getTutorBookings(@PathVariable String tutorId) {
        try {
            BookingListResponse bookings = bookingService.getTutorBookingList(tutorId);
            return ResponseEntity.ok(bookings);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateBooking(@PathVariable String id, @RequestBody UpdateBookingRequest request) {
        try {
            BookingDetailResponse booking = bookingService.updateBooking(id, request);
            return ResponseEntity.ok(booking);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/confirm")
    public ResponseEntity<?> confirmBooking(@PathVariable String id) {
        try {
            BookingDetailResponse booking = bookingService.confirmBooking(id);
            return ResponseEntity.ok(booking);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<?> cancelBooking(@PathVariable String id) {
        try {
            bookingService.cancelBooking(id);
            return ResponseEntity.ok("Booking cancelled successfully");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/complete")
    public ResponseEntity<?> completeBooking(@PathVariable String id) {
        try {
            bookingService.completeBooking(id);
            return ResponseEntity.ok("Booking completed successfully");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\DashboardController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.response.StudentDashboardResponse;
import com.tutoringplatform.dto.response.TutorDashboardResponse;
import com.tutoringplatform.services.DashboardService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/dashboard")
public class DashboardController {

    private final DashboardService dashboardService;

    @Autowired
    public DashboardController(DashboardService dashboardService) {
        this.dashboardService = dashboardService;
    }

    @GetMapping("/student/{studentId}")
    public ResponseEntity<?> getStudentDashboard(@PathVariable String studentId) {
        try {
            StudentDashboardResponse dashboard = dashboardService.getStudentDashboard(studentId);
            return ResponseEntity.ok(dashboard);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/tutor/{tutorId}")
    public ResponseEntity<?> getTutorDashboard(@PathVariable String tutorId) {
        try {
            TutorDashboardResponse dashboard = dashboardService.getTutorDashboard(tutorId);
            return ResponseEntity.ok(dashboard);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\FileController.java
======================================================================

// FILE: src/main/java/com/tutoringplatform/controllers/FileController.java
package com.tutoringplatform.controllers;

import com.tutoringplatform.services.FileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import java.util.Map;

@RestController
@RequestMapping("/api/files")
public class FileController {

    private final FileService fileService;

    @Autowired
    public FileController(FileService fileService) {
        this.fileService = fileService;
    }

    @PostMapping("/upload/{userId}")
    public ResponseEntity<?> uploadFile(
            @PathVariable String userId,
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") String fileType) {
        try {
            String fileId = fileService.storeFile(userId, file, fileType);
            return ResponseEntity.ok(Map.of("fileId", fileId, "fileName", file.getOriginalFilename()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    @GetMapping("/{fileId}")
    public ResponseEntity<?> downloadFile(@PathVariable String fileId) {
        try {
            Resource resource = fileService.loadFile(fileId);

            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION,
                            "attachment; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @DeleteMapping("/{fileId}")
    public ResponseEntity<?> deleteFile(@PathVariable String fileId) {
        try {
            fileService.deleteFile(fileId);
            return ResponseEntity.ok("File deleted successfully");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\PaymentController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.response.PaymentHistoryResponse;
import com.tutoringplatform.dto.response.TransactionRecord;
import com.tutoringplatform.services.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    private final PaymentService paymentService;

    @Autowired
    public PaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    /*@GetMapping("/history/{studentId}")
    public ResponseEntity<?> getPaymentHistory(@PathVariable String studentId) {
        try {
            PaymentHistoryResponse history = paymentService.getStudentPaymentHistory(studentId);
            return ResponseEntity.ok(history);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }*/

}



======================================================================
// FILE: java\com\tutoringplatform\controllers\ReviewController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.request.CreateReviewRequest;
import com.tutoringplatform.dto.response.ReviewResponse;
import com.tutoringplatform.services.ReviewService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.util.List;

@RestController
@RequestMapping("/api/reviews")
public class ReviewController {

    private final ReviewService reviewService;

    @Autowired
    public ReviewController(ReviewService reviewService) {
        this.reviewService = reviewService;
    }

    @PostMapping
    public ResponseEntity<?> createReview(@RequestBody CreateReviewRequest request) {
        try {
            ReviewResponse review = reviewService.createReview(request);
            return ResponseEntity.status(HttpStatus.CREATED).body(review);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/tutor/{tutorId}")
    public ResponseEntity<?> getTutorReviews(@PathVariable String tutorId) {
        try {
            List<ReviewResponse> reviews = reviewService.getTutorReviewsWithDetails(tutorId);
            return ResponseEntity.ok(reviews);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\SearchController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.request.TutorSearchRequest;
import com.tutoringplatform.dto.response.TutorSearchResultsResponse;
import com.tutoringplatform.services.SearchService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;

@RestController
@RequestMapping("/api/search")
public class SearchController {

    private final SearchService searchService;

    @Autowired
    public SearchController(SearchService searchService) {
        this.searchService = searchService;
    }

    @PostMapping("/tutors")
    public ResponseEntity<?> searchTutors(@RequestBody TutorSearchRequest request) {
        try {
            TutorSearchResultsResponse results = searchService.searchTutors(request);
            return ResponseEntity.ok(results);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\StudentController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.request.AddFundsRequest;
import com.tutoringplatform.dto.request.UpdateProfileRequest;
import com.tutoringplatform.dto.response.StudentProfileResponse;
import com.tutoringplatform.dto.response.ValueResponse;
import com.tutoringplatform.services.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.web.multipart.MultipartFile;
import java.util.Map;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    private final StudentService studentService;

    @Autowired
    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getStudent(@PathVariable String id) {
        try {
            StudentProfileResponse profile = studentService.getStudentProfile(id);
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateStudent(@PathVariable String id, @RequestBody UpdateProfileRequest request) {
        try {
            StudentProfileResponse profile = studentService.updateStudentProfile(id, request);
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/profile-picture")
    public ResponseEntity<?> updateProfilePicture(
            @PathVariable String id,
            @RequestParam("file") MultipartFile file) {
        try {
            Map<String, String> result = studentService.updateProfilePicture(id, file);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/add-funds")
    public ResponseEntity<?> addFunds(@PathVariable String id, @RequestBody AddFundsRequest request) {
        try {
            ValueResponse<Double> balance = studentService.addFunds(id, request.getAmount());
            return ResponseEntity.ok(balance);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}/balance")
    public ResponseEntity<?> getBalance(@PathVariable String id) {
        try {
            ValueResponse<Double> balance = studentService.getBalance(id);
            return ResponseEntity.ok(balance);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\SubjectController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.response.SubjectListResponse;
import com.tutoringplatform.dto.response.SubjectResponse;
import com.tutoringplatform.services.SubjectService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import java.util.List;

@RestController
@RequestMapping("/api/subjects")
public class SubjectController {

    private final SubjectService subjectService;

    @Autowired
    public SubjectController(SubjectService subjectService) {
        this.subjectService = subjectService;
    }

    @GetMapping
    public ResponseEntity<?> getAllSubjects() {
        try {
            SubjectListResponse subjects = subjectService.getAllSubjects();
            return ResponseEntity.ok(subjects);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
        }
    }

    @GetMapping("/category")
    public ResponseEntity<?> getAllSubjectsByCategory() {
        try {
            SubjectListResponse subjects = subjectService.getAllSubjectsByCategory();
            return ResponseEntity.ok(subjects);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getSubjectById(@PathVariable String id) {
        try {
            SubjectResponse subject = subjectService.getSubjectById(id);
            return ResponseEntity.ok(subject);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/available/tutor/{tutorId}")
    public ResponseEntity<?> getAvailableSubjectsForTutor(@PathVariable String tutorId) {
        try {
            List<SubjectResponse> subjects = subjectService.getAvailableSubjectsForTutor(tutorId);
            return ResponseEntity.ok(subjects);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\controllers\TutorController.java
======================================================================

package com.tutoringplatform.controllers;

import com.tutoringplatform.dto.request.UpdateProfileRequest;
import com.tutoringplatform.dto.request.TutorAvailabilityRequest;
import com.tutoringplatform.dto.request.AddSubjectToTutorRequest;
import com.tutoringplatform.dto.response.TutorProfileResponse;
import com.tutoringplatform.dto.response.ValueResponse;
import com.tutoringplatform.dto.response.AvailabilityResponse;
import com.tutoringplatform.services.TutorService;
import com.tutoringplatform.services.AvailabilityService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.web.multipart.MultipartFile;
import java.util.Map;
import java.util.List;

@RestController
@RequestMapping("/api/tutors")
public class TutorController {

    private final TutorService tutorService;
    private final AvailabilityService availabilityService;

    @Autowired
    public TutorController(TutorService tutorService, AvailabilityService availabilityService) {
        this.tutorService = tutorService;
        this.availabilityService = availabilityService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getTutor(@PathVariable String id) {
        try {
            TutorProfileResponse profile = tutorService.getTutorProfile(id);
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping
    public ResponseEntity<?> getAllTutors() {
        try {
            List<TutorProfileResponse> tutors = tutorService.getAllTutorProfiles();
            return ResponseEntity.ok(tutors);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateTutor(@PathVariable String id, @RequestBody UpdateProfileRequest request) {
        try {
            TutorProfileResponse profile = tutorService.updateTutorProfile(id, request);
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/profile-picture")
    public ResponseEntity<?> updateProfilePicture(
            @PathVariable String id,
            @RequestParam("file") MultipartFile file) {
        try {
            Map<String, String> result = tutorService.updateProfilePicture(id, file);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/availability")
    public ResponseEntity<?> updateAvailability(
            @PathVariable String id,
            @RequestBody TutorAvailabilityRequest request) {
        try {
            AvailabilityResponse availability = availabilityService.updateTutorAvailability(id, request);
            return ResponseEntity.ok(availability);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}/availability")
    public ResponseEntity<?> getTutorAvailability(@PathVariable String id) {
        try {
            AvailabilityResponse availability = availabilityService.getTutorAvailability(id);
            return ResponseEntity.ok(availability);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @PostMapping("/{id}/subjects")
    public ResponseEntity<?> addSubject(@PathVariable String id, @RequestBody AddSubjectToTutorRequest request) {
        try {
            TutorProfileResponse profile = tutorService.addSubjectToTutor(id, request.getSubjectId());
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @DeleteMapping("/{id}/subjects/{subjectId}")
    public ResponseEntity<?> removeSubject(@PathVariable String id, @PathVariable String subjectId) {
        try {
            TutorProfileResponse profile = tutorService.removeSubjectFromTutor(id, subjectId);
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @GetMapping("/{id}/earnings")
    public ResponseEntity<?> getEarnings(@PathVariable String id) {
        try {
            ValueResponse<Double> earnings = tutorService.getEarnings(id);
            return ResponseEntity.ok(earnings);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @GetMapping("/{id}/average-rating")
    public ResponseEntity<?> getAverageRating(@PathVariable String id) {
        try {
            ValueResponse<Double> rating = tutorService.getAverageRating(id);
            return ResponseEntity.ok(rating);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\AddFundsRequest.java
======================================================================

package com.tutoringplatform.dto.request;

public class AddFundsRequest {
    private double amount;

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\AddSubjectToTutorRequest.java
======================================================================

package com.tutoringplatform.dto.request;

public class AddSubjectToTutorRequest {
    private String subjectId;

    public String getSubjectId() {
        return subjectId;
    }

    public void setSubjectId(String subjectId) {
        this.subjectId = subjectId;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\CreateBookingRequest.java
======================================================================

package com.tutoringplatform.dto.request;

import java.time.LocalDateTime;

public class CreateBookingRequest {
    private String studentId;
    private String tutorId;
    private String subjectId;
    private LocalDateTime dateTime;
    private int durationHours;

    public String getStudentId() {
        return studentId;
    }

    public void setStudentId(String studentId) {
        this.studentId = studentId;
    }

    public String getTutorId() {
        return tutorId;
    }

    public void setTutorId(String tutorId) {
        this.tutorId = tutorId;
    }

    public String getSubjectId() {
        return subjectId;
    }

    public void setSubjectId(String subjectId) {
        this.subjectId = subjectId;
    }

    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getDurationHours() {
        return durationHours;
    }

    public void setDurationHours(int durationHours) {
        this.durationHours = durationHours;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\CreateReviewRequest.java
======================================================================

package com.tutoringplatform.dto.request;

public class CreateReviewRequest {
    private String studentId;
    private String tutorId;
    private int rating;
    private String comment;

    public String getStudentId() {
        return studentId;
    }

    public void setStudentId(String studentId) {
        this.studentId = studentId;
    }

    public String getTutorId() {
        return tutorId;
    }

    public void setTutorId(String tutorId) {
        this.tutorId = tutorId;
    }

    public int getRating() {
        return rating;
    }

    public void setRating(int rating) {
        this.rating = rating;
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\LoginRequest.java
======================================================================

package com.tutoringplatform.dto.request;

public class LoginRequest {
    private String email;
    private String password;

    // Getters and setters
    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\SignupRequest.java
======================================================================

package com.tutoringplatform.dto.request;

public class SignupRequest {
    private String userType; // "STUDENT" or "TUTOR"
    private String name;
    private String email;
    private String password;
    private String timeZoneId;
    private double hourlyRate; // Required if tutor
    private String description; // Required if tutor

    public String getUserType() {
        return userType;
    }

    public void setUserType(String userType) {
        this.userType = userType;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getTimeZoneId() {
        return timeZoneId;
    }

    public void setTimeZoneId(String timeZoneId) {
        this.timeZoneId = timeZoneId;
    }

    public double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\TutorAvailabilityRequest.java
======================================================================

package com.tutoringplatform.dto.request;

import java.time.DayOfWeek;
import java.time.LocalTime;

public class TutorAvailabilityRequest {
    private String action; // "ADD" or "REMOVE"
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    // All getters and setters
    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public DayOfWeek getDayOfWeek() {
        return dayOfWeek;
    }

    public void setDayOfWeek(DayOfWeek dayOfWeek) {
        this.dayOfWeek = dayOfWeek;
    }

    public LocalTime getStartTime() {
        return startTime;
    }

    public void setStartTime(LocalTime startTime) {
        this.startTime = startTime;
    }

    public LocalTime getEndTime() {
        return endTime;
    }

    public void setEndTime(LocalTime endTime) {
        this.endTime = endTime;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\TutorSearchRequest.java
======================================================================

package com.tutoringplatform.dto.request;

import java.time.LocalDateTime;

public class TutorSearchRequest {
    private String subjectId;
    private double minPrice;
    private double maxPrice;
    private double minRating;
    private Boolean availableNow;
    private LocalDateTime availableDateTime;
    private String searchText;
    private String sortBy; // "PRICE_LOW", "PRICE_HIGH", "RATING", "REVIEWS"
    private Integer page;
    private Integer pageSize;

    // All getters and setters
    public String getSubjectId() {
        return subjectId;
    }

    public void setSubjectId(String subjectId) {
        this.subjectId = subjectId;
    }

    public double getMinPrice() {
        return minPrice;
    }

    public void setMinPrice(double minPrice) {
        this.minPrice = minPrice;
    }

    public double getMaxPrice() {
        return maxPrice;
    }

    public void setMaxPrice(double maxPrice) {
        this.maxPrice = maxPrice;
    }

    public double getMinRating() {
        return minRating;
    }

    public void setMinRating(double minRating) {
        this.minRating = minRating;
    }

    public Boolean getAvailableNow() {
        return availableNow;
    }

    public void setAvailableNow(Boolean availableNow) {
        this.availableNow = availableNow;
    }

    public LocalDateTime getAvailableDateTime() {
        return availableDateTime;
    }

    public void setAvailableDateTime(LocalDateTime availableDateTime) {
        this.availableDateTime = availableDateTime;
    }

    public String getSearchText() {
        return searchText;
    }

    public void setSearchText(String searchText) {
        this.searchText = searchText;
    }

    public String getSortBy() {
        return sortBy;
    }

    public void setSortBy(String sortBy) {
        this.sortBy = sortBy;
    }

    public Integer getPage() {
        return page;
    }

    public void setPage(Integer page) {
        this.page = page;
    }

    public Integer getPageSize() {
        return pageSize;
    }

    public void setPageSize(Integer pageSize) {
        this.pageSize = pageSize;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\UpdateBookingRequest.java
======================================================================

package com.tutoringplatform.dto.request;

import java.time.LocalDateTime;

public class UpdateBookingRequest {
    private LocalDateTime dateTime;
    private int durationHours;

    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getDurationHours() {
        return durationHours;
    }

    public void setDurationHours(int durationHours) {
        this.durationHours = durationHours;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\request\UpdateProfileRequest.java
======================================================================

package com.tutoringplatform.dto.request;

public class UpdateProfileRequest {
    private String name;
    private String email;
    private String password;
    private String currentPassword; // Required if changing password
    private String timeZoneId;
    private Double hourlyRate; // Tutor only
    private String description; // Tutor only

    // All getters and setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getCurrentPassword() {
        return currentPassword;
    }

    public void setCurrentPassword(String currentPassword) {
        this.currentPassword = currentPassword;
    }

    public String getTimeZoneId() {
        return timeZoneId;
    }

    public void setTimeZoneId(String timeZoneId) {
        this.timeZoneId = timeZoneId;
    }

    public Double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(Double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\AuthResponse.java
======================================================================

package com.tutoringplatform.dto.response;

public class AuthResponse {
    private String id;
    private String name;
    private String email;
    private String userType;
    private double balance; // Students only
    private double hourlyRate; // Tutors only
    private String profilePictureUrl;
    private String timeZoneId;

    // All getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getUserType() {
        return userType;
    }

    public void setUserType(String userType) {
        this.userType = userType;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }

    public void setProfilePictureUrl(String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    public String getTimeZoneId() {
        return timeZoneId;
    }

    public void setTimeZoneId(String timeZoneId) {
        this.timeZoneId = timeZoneId;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\AvailabilityResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.time.LocalDateTime;
import java.util.List;

import com.tutoringplatform.models.availability.AvailabilityException;
import com.tutoringplatform.models.availability.RecurringAvailability;

public class AvailabilityResponse {
    private String tutorId;
    private String timeZone;
    private List<RecurringAvailability> regularSchedule;
    private List<AvailabilityException> exceptions;
    private LocalDateTime nextAvailableSlot;

    public String getTutorId() {
        return tutorId;
    }

    public void setTutorId(String tutorId) {
        this.tutorId = tutorId;
    }

    public String getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }

    public List<RecurringAvailability> getRegularSchedule() {
        return regularSchedule;
    }

    public void setRegularSchedule(List<RecurringAvailability> regularSchedule) {
        this.regularSchedule = regularSchedule;
    }

    public List<AvailabilityException> getExceptions() {
        return exceptions;
    }

    public void setExceptions(List<AvailabilityException> exceptions) {
        this.exceptions = exceptions;
    }

    public LocalDateTime getNextAvailableSlot() {
        return nextAvailableSlot;
    }

    public void setNextAvailableSlot(LocalDateTime nextAvailableSlot) {
        this.nextAvailableSlot = nextAvailableSlot;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\BookingDetailResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.time.LocalDateTime;

import com.tutoringplatform.dto.response.info.PaymentInfo;
import com.tutoringplatform.dto.response.info.TutorInfo;
import com.tutoringplatform.dto.response.info.UserInfo;

public class BookingDetailResponse {
    private String id;
    private UserInfo student;
    private TutorInfo tutor;
    private SubjectResponse subject;
    private LocalDateTime dateTime;
    private int durationHours;
    private double totalCost;
    private String status;
    private PaymentInfo payment;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public UserInfo getStudent() {
        return student;
    }

    public void setStudent(UserInfo student) {
        this.student = student;
    }

    public TutorInfo getTutor() {
        return tutor;
    }

    public void setTutor(TutorInfo tutor) {
        this.tutor = tutor;
    }

    public SubjectResponse getSubject() {
        return subject;
    }

    public void setSubject(SubjectResponse subject) {
        this.subject = subject;
    }

    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }

    public int getDurationHours() {
        return durationHours;
    }

    public void setDurationHours(int durationHours) {
        this.durationHours = durationHours;
    }

    public double getTotalCost() {
        return totalCost;
    }

    public void setTotalCost(double totalCost) {
        this.totalCost = totalCost;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public PaymentInfo getPayment() {
        return payment;
    }

    public void setPayment(PaymentInfo payment) {
        this.payment = payment;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\BookingListResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

public class BookingListResponse {
    private List<BookingDetailResponse> upcomingBookings;
    private List<BookingDetailResponse> pastBookings;
    private List<BookingDetailResponse> cancelledBookings;

    // All getters and setters
    public List<BookingDetailResponse> getUpcomingBookings() {
        return upcomingBookings;
    }

    public void setUpcomingBookings(List<BookingDetailResponse> upcomingBookings) {
        this.upcomingBookings = upcomingBookings;
    }

    public List<BookingDetailResponse> getPastBookings() {
        return pastBookings;
    }

    public void setPastBookings(List<BookingDetailResponse> pastBookings) {
        this.pastBookings = pastBookings;
    }

    public List<BookingDetailResponse> getCancelledBookings() {
        return cancelledBookings;
    }

    public void setCancelledBookings(List<BookingDetailResponse> cancelledBookings) {
        this.cancelledBookings = cancelledBookings;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\CategorySubjects.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

import com.tutoringplatform.dto.response.info.SubjectInfo;

public class CategorySubjects {
    private String category;
    private List<SubjectInfo> subjects;

    public String getCategory() {
        return category;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public List<SubjectInfo> getSubjects() {
        return subjects;
    }

    public void setSubjects(List<SubjectInfo> subjects) {
        this.subjects = subjects;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\DashboardStats.java
======================================================================

package com.tutoringplatform.dto.response;

public class DashboardStats {
    private int totalSessions;
    private int completedSessions;
    private int upcomingSessions;
    private double totalEarnings; // Tutors only
    private double thisMonthEarnings; // Tutors only
    private double averageRating; // Tutors only
    private int totalReviews; // Tutors only

    // All getters and setters
    public int getTotalSessions() {
        return totalSessions;
    }

    public void setTotalSessions(int totalSessions) {
        this.totalSessions = totalSessions;
    }

    public int getCompletedSessions() {
        return completedSessions;
    }

    public void setCompletedSessions(int completedSessions) {
        this.completedSessions = completedSessions;
    }

    public int getUpcomingSessions() {
        return upcomingSessions;
    }

    public void setUpcomingSessions(int upcomingSessions) {
        this.upcomingSessions = upcomingSessions;
    }

    public double getTotalEarnings() {
        return totalEarnings;
    }

    public void setTotalEarnings(double totalEarnings) {
        this.totalEarnings = totalEarnings;
    }

    public double getThisMonthEarnings() {
        return thisMonthEarnings;
    }

    public void setThisMonthEarnings(double thisMonthEarnings) {
        this.thisMonthEarnings = thisMonthEarnings;
    }

    public double getAverageRating() {
        return averageRating;
    }

    public void setAverageRating(double averageRating) {
        this.averageRating = averageRating;
    }

    public int getTotalReviews() {
        return totalReviews;
    }

    public void setTotalReviews(int totalReviews) {
        this.totalReviews = totalReviews;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\PaymentHistoryResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

public class PaymentHistoryResponse {
    private List<TransactionRecord> transactions;
    private double totalSpent;
    private double currentBalance;

    public List<TransactionRecord> getTransactions() {
        return transactions;
    }

    public void setTransactions(List<TransactionRecord> transactions) {
        this.transactions = transactions;
    }

    public double getTotalSpent() {
        return totalSpent;
    }

    public void setTotalSpent(double totalSpent) {
        this.totalSpent = totalSpent;
    }

    public double getCurrentBalance() {
        return currentBalance;
    }

    public void setCurrentBalance(double currentBalance) {
        this.currentBalance = currentBalance;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\ReviewResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.time.LocalDateTime;

import com.tutoringplatform.dto.response.info.ReviewInfo;
import com.tutoringplatform.dto.response.info.UserInfo;

public class ReviewResponse {
    private String id;
    private ReviewInfo review;
    private UserInfo studentInfo;
    private UserInfo tutorInfo;
    private int rating;
    private String comment;
    private LocalDateTime createdAt;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public ReviewInfo getReview() {
        return review;
    }

    public void setReview(ReviewInfo review) {
        this.review = review;
    }

    public UserInfo getStudentInfo() {
        return studentInfo;
    }

    public void setStudentInfo(UserInfo studentInfo) {
        this.studentInfo = studentInfo;
    }

    public UserInfo getTutorInfo() {
        return tutorInfo;
    }

    public void setTutorInfo(UserInfo tutorInfo) {
        this.tutorInfo = tutorInfo;
    }

    public int getRating() {
        return rating;
    }

    public void setRating(int rating) {
        this.rating = rating;
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\SearchFilters.java
======================================================================

package com.tutoringplatform.dto.response;

public class SearchFilters {
    private String subjectId;
    private double minPrice;
    private double maxPrice;
    private double minRating;
    private String sortBy;

    // All getters and setters
    public String getSubjectId() {
        return subjectId;
    }

    public void setSubjectId(String subjectId) {
        this.subjectId = subjectId;
    }

    public double getMinPrice() {
        return minPrice;
    }

    public void setMinPrice(double minPrice) {
        this.minPrice = minPrice;
    }

    public double getMaxPrice() {
        return maxPrice;
    }

    public void setMaxPrice(double maxPrice) {
        this.maxPrice = maxPrice;
    }

    public double getMinRating() {
        return minRating;
    }

    public void setMinRating(double minRating) {
        this.minRating = minRating;
    }

    public String getSortBy() {
        return sortBy;
    }

    public void setSortBy(String sortBy) {
        this.sortBy = sortBy;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\StudentDashboardResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

public class StudentDashboardResponse {
    private UserProfile profile;
    private DashboardStats stats;
    private List<BookingDetailResponse> upcomingBookings;

    // All getters and setters
    public UserProfile getProfile() {
        return profile;
    }

    public void setProfile(UserProfile profile) {
        this.profile = profile;
    }

    public DashboardStats getStats() {
        return stats;
    }

    public void setStats(DashboardStats stats) {
        this.stats = stats;
    }

    public List<BookingDetailResponse> getUpcomingBookings() {
        return upcomingBookings;
    }

    public void setUpcomingBookings(List<BookingDetailResponse> upcomingBookings) {
        this.upcomingBookings = upcomingBookings;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\StudentProfileResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.time.LocalDate;

public class StudentProfileResponse {
    private String id;
    private String name;
    private String email;
    private String profilePictureUrl;
    private double balance;
    private String timeZoneId;
    private LocalDate joinedDate;
    private int totalSessions;

    // All getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }

    public void setProfilePictureUrl(String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String getTimeZoneId() {
        return timeZoneId;
    }

    public void setTimeZoneId(String timeZoneId) {
        this.timeZoneId = timeZoneId;
    }

    public LocalDate getJoinedDate() {
        return joinedDate;
    }

    public void setJoinedDate(LocalDate joinedDate) {
        this.joinedDate = joinedDate;
    }

    public int getTotalSessions() {
        return totalSessions;
    }

    public void setTotalSessions(int totalSessions) {
        this.totalSessions = totalSessions;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\SubjectListResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

public class SubjectListResponse {
    private List<CategorySubjects> subjects;

    public List<CategorySubjects> getSubjects() {
        return subjects;
    }

    public void setSubjects(List<CategorySubjects> subjects) {
        this.subjects = subjects;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\SubjectResponse.java
======================================================================

package com.tutoringplatform.dto.response;

public class SubjectResponse {
    private String id;
    private String name;
    private String category;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCategory() {
        return category;
    }

    public void setCategory(String category) {
        this.category = category;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\TransactionRecord.java
======================================================================

package com.tutoringplatform.dto.response;

import com.tutoringplatform.dto.response.info.BookingInfo;
import java.time.LocalDateTime;

public class TransactionRecord {
    private String id;
    private TransactionType type;
    private double amount;
    private LocalDateTime date;
    private BookingInfo booking;

    public enum TransactionType {
        PAYMENT,
        REFUND
    }

    // Getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public TransactionType getType() {
        return type;
    }

    public void setType(TransactionType type) {
        this.type = type;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public LocalDateTime getDate() {
        return date;
    }

    public void setDate(LocalDateTime date) {
        this.date = date;
    }

    public BookingInfo getBooking() {
        return booking;
    }

    public void setBooking(BookingInfo booking) {
        this.booking = booking;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\TutorDashboardResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

public class TutorDashboardResponse {
    private UserProfile profile;
    private DashboardStats stats;
    private List<BookingDetailResponse> upcomingBookings;
    private List<BookingDetailResponse> todaysSchedule;

    // All getters and setters
    public UserProfile getProfile() {
        return profile;
    }

    public void setProfile(UserProfile profile) {
        this.profile = profile;
    }

    public DashboardStats getStats() {
        return stats;
    }

    public void setStats(DashboardStats stats) {
        this.stats = stats;
    }

    public List<BookingDetailResponse> getUpcomingBookings() {
        return upcomingBookings;
    }

    public void setUpcomingBookings(List<BookingDetailResponse> upcomingBookings) {
        this.upcomingBookings = upcomingBookings;
    }

    public List<BookingDetailResponse> getTodaysSchedule() {
        return todaysSchedule;
    }

    public void setTodaysSchedule(List<BookingDetailResponse> todaysSchedule) {
        this.todaysSchedule = todaysSchedule;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\TutorProfileResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.time.LocalDate;
import java.util.List;
import com.tutoringplatform.models.availability.RecurringAvailability;

public class TutorProfileResponse {
    private String id;
    private String name;
    private String email;
    private String profilePictureUrl;
    private double hourlyRate;
    private String description;
    private double rating;
    private int totalReviews;
    private List<SubjectResponse> subjects;
    private List<RecurringAvailability> availability;
    private List<ReviewResponse> reviews;
    private int completedSessions;
    private LocalDate joinedDate;

    // All getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }

    public void setProfilePictureUrl(String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    public double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public double getRating() {
        return rating;
    }

    public void setRating(double rating) {
        this.rating = rating;
    }

    public int getTotalReviews() {
        return totalReviews;
    }

    public void setTotalReviews(int totalReviews) {
        this.totalReviews = totalReviews;
    }

    public List<SubjectResponse> getSubjects() {
        return subjects;
    }

    public void setSubjects(List<SubjectResponse> subjects) {
        this.subjects = subjects;
    }

    public List<RecurringAvailability> getAvailability() {
        return availability;
    }

    public void setAvailability(List<RecurringAvailability> availability) {
        this.availability = availability;
    }

    public List<ReviewResponse> getReviews() {
        return reviews;
    }

    public void setReviews(List<ReviewResponse> reviews) {
        this.reviews = reviews;
    }

    public int getCompletedSessions() {
        return completedSessions;
    }

    public void setCompletedSessions(int completedSessions) {
        this.completedSessions = completedSessions;
    }

    public LocalDate getJoinedDate() {
        return joinedDate;
    }

    public void setJoinedDate(LocalDate joinedDate) {
        this.joinedDate = joinedDate;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\TutorSearchResultsResponse.java
======================================================================

package com.tutoringplatform.dto.response;

import java.util.List;

import com.tutoringplatform.dto.response.info.TutorSearchResultInfo;

public class TutorSearchResultsResponse {
    private List<TutorSearchResultInfo> results;
    private int totalCount;
    private SearchFilters filters;

    // All getters and setters
    public List<TutorSearchResultInfo> getResults() {
        return results;
    }

    public void setResults(List<TutorSearchResultInfo> results) {
        this.results = results;
    }

    public int getTotalCount() {
        return totalCount;
    }

    public void setTotalCount(int totalCount) {
        this.totalCount = totalCount;
    }

    public SearchFilters getFilters() {
        return filters;
    }

    public void setFilters(SearchFilters filters) {
        this.filters = filters;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\UserProfile.java
======================================================================

package com.tutoringplatform.dto.response;

public class UserProfile {
    private String name;
    private double balance; // Students only
    private double hourlyRate; // Tutors only
    private String profilePictureUrl;

    // All getters and setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }

    public void setProfilePictureUrl(String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\ValueResponse.java
======================================================================

package com.tutoringplatform.dto.response;

public class ValueResponse<T> {
    private T value;
    private String message;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\BookingInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

import java.time.LocalDateTime;

public class BookingInfo {
    private String bookingId;
    private String tutorName;
    private String subjectName;
    private LocalDateTime sessionDate;

    // Getters and setters
    public String getBookingId() {
        return bookingId;
    }

    public void setBookingId(String bookingId) {
        this.bookingId = bookingId;
    }

    public String getTutorName() {
        return tutorName;
    }

    public void setTutorName(String tutorName) {
        this.tutorName = tutorName;
    }

    public String getSubjectName() {
        return subjectName;
    }

    public void setSubjectName(String subjectName) {
        this.subjectName = subjectName;
    }

    public LocalDateTime getSessionDate() {
        return sessionDate;
    }

    public void setSessionDate(LocalDateTime sessionDate) {
        this.sessionDate = sessionDate;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\PaymentInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

import java.time.LocalDateTime;

public class PaymentInfo {
    private String status;
    private LocalDateTime paidAt;

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public LocalDateTime getPaidAt() {
        return paidAt;
    }

    public void setPaidAt(LocalDateTime paidAt) {
        this.paidAt = paidAt;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\ReviewInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

public class ReviewInfo {
    private int rating;
    private String comment;

    public int getRating() {
        return rating;
    }

    public void setRating(int rating) {
        this.rating = rating;
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\SubjectInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

public class SubjectInfo {
    private String id;
    private String name;
    private int tutorCount;
    private double averagePrice;

    // All getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getTutorCount() {
        return tutorCount;
    }

    public void setTutorCount(int tutorCount) {
        this.tutorCount = tutorCount;
    }

    public double getAveragePrice() {
        return averagePrice;
    }

    public void setAveragePrice(double averagePrice) {
        this.averagePrice = averagePrice;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\TutorInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

public class TutorInfo extends UserInfo {
    private double hourlyRate;

    public double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\TutorSearchResultInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

import java.time.LocalDateTime;
import java.util.List;

import com.tutoringplatform.dto.response.SubjectResponse;

public class TutorSearchResultInfo {
    private String id;
    private String name;
    private String profilePictureUrl;
    private double hourlyRate;
    private double rating;
    private int reviewCount;
    private List<SubjectResponse> subjects;
    private String shortDescription;
    private LocalDateTime nextAvailable;

    // All getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }

    public void setProfilePictureUrl(String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    public double getHourlyRate() {
        return hourlyRate;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }

    public double getRating() {
        return rating;
    }

    public void setRating(double rating) {
        this.rating = rating;
    }

    public int getReviewCount() {
        return reviewCount;
    }

    public void setReviewCount(int reviewCount) {
        this.reviewCount = reviewCount;
    }

    public List<SubjectResponse> getSubjects() {
        return subjects;
    }

    public void setSubjects(List<SubjectResponse> subjects) {
        this.subjects = subjects;
    }

    public String getShortDescription() {
        return shortDescription;
    }

    public void setShortDescription(String shortDescription) {
        this.shortDescription = shortDescription;
    }

    public LocalDateTime getNextAvailable() {
        return nextAvailable;
    }

    public void setNextAvailable(LocalDateTime nextAvailable) {
        this.nextAvailable = nextAvailable;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\dto\response\info\UserInfo.java
======================================================================

package com.tutoringplatform.dto.response.info;

public class UserInfo {
    private String id;
    private String name;
    private String profilePictureUrl;

    // All getters and setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }

    public void setProfilePictureUrl(String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\factory\UserFactory.java
======================================================================

// FILE: src/main/java/com/tutoringplatform/factory/UserFactory.java
package com.tutoringplatform.factory;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;

import org.springframework.stereotype.Component;

@Component
public class UserFactory {

    public enum UserType {
        STUDENT,
        TUTOR
    }

    public Student createStudent(String name, String email, String password) {
        return new Student(name, email, password);
    }

    public Tutor createTutor(String name, String email, String password, double hourlyRate, String description) {
        return new Tutor(name, email, password, hourlyRate, description);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\Booking.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;
import java.util.UUID;

public class Booking {
    private String id;
    private String studentId;
    private String tutorId;
    private Subject subject;
    private LocalDateTime dateTime;
    private int durationHours;
    private double totalCost;
    private BookingStatus status;
    private Payment payment;

    public enum BookingStatus {
        PENDING, CONFIRMED, COMPLETED, CANCELLED
    }

    public Booking(String studentId, String tutorId, Subject subject, LocalDateTime dateTime, int durationHours, double hourlyRate) {
        this.id = UUID.randomUUID().toString();
        this.studentId = studentId;
        this.tutorId = tutorId;
        this.subject = subject;
        this.dateTime = dateTime;
        this.durationHours = durationHours;
        this.totalCost = hourlyRate * durationHours;
        this.status = BookingStatus.PENDING;
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getStudentId() { return studentId; }
    public void setStudentId(String studentId) { this.studentId = studentId; }

    public String getTutorId() { return tutorId; }
    public void setTutorId(String tutorId) { this.tutorId = tutorId; }

    public Subject getSubject() { return subject; }
    public void setSubject(Subject subject) { this.subject = subject; }

    public LocalDateTime getDateTime() { return dateTime; }
    public void setDateTime(LocalDateTime dateTime) { this.dateTime = dateTime; }

    public int getDurationHours() { return durationHours; }
    public void setDurationHours(int durationHours) { this.durationHours = durationHours; }

    public double getTotalCost() { return totalCost; }
    public void setTotalCost(double totalCost) { this.totalCost = totalCost; }

    public BookingStatus getStatus() { return status; }
    public void setStatus(BookingStatus status) { this.status = status; }

    public Payment getPayment() { return payment; }
    public void setPayment(Payment payment) { this.payment = payment; }
}



======================================================================
// FILE: java\com\tutoringplatform\models\FileMetaData.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;

public class FileMetaData {
    private String fileId;
    private String userId;
    private String originalFileName;
    private String fileType;
    private String storedFileName;
    private LocalDateTime uploadTime;

    public FileMetaData(String fileId, String userId, String originalFileName,
            String fileType, String storedFileName) {
        this.fileId = fileId;
        this.userId = userId;
        this.originalFileName = originalFileName;
        this.fileType = fileType;
        this.storedFileName = storedFileName;
        this.uploadTime = LocalDateTime.now();
    }

    public String getFileId() {
        return fileId;
    }

    public void setFileId(String fileId) {
        this.fileId = fileId;
    }
    public String getUserId() {
        return userId;
    }    

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getOriginalFileName() {
        return originalFileName;
    }

    public void setOriginalFileName(String originalFileName) {
        this.originalFileName = originalFileName;
    }

    public String getFileType() {
        return fileType;
    }

    public void setFileType(String fileType) {
        this.fileType = fileType;
    }

    public String getStoredFileName() {
        return storedFileName;
    }

    public void setStoredFileName(String storedFileName) {
        this.storedFileName = storedFileName;
    }
    
    public LocalDateTime getUploadTime() {
        return uploadTime;
    }

    public void setUploadTime(LocalDateTime uploadTime) {
        this.uploadTime = uploadTime;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\Payment.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;
import java.util.UUID;

public class Payment {
    private String id;
    private String bookingId;
    private double amount;
    private PaymentStatus status;
    private LocalDateTime timestamp;
    private String transactionId;

    public enum PaymentStatus {
        PENDING, COMPLETED, FAILED, REFUNDED
    }

    public Payment(String bookingId, double amount) {
        this.id = UUID.randomUUID().toString();
        this.bookingId = bookingId;
        this.amount = amount;
        this.status = PaymentStatus.PENDING;
        this.timestamp = LocalDateTime.now();
        this.transactionId = UUID.randomUUID().toString();
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getBookingId() { return bookingId; }
    public void setBookingId(String bookingId) { this.bookingId = bookingId; }

    public double getAmount() { return amount; }
    public void setAmount(double amount) { this.amount = amount; }

    public PaymentStatus getStatus() { return status; }
    public void setStatus(PaymentStatus status) { this.status = status; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }
}



======================================================================
// FILE: java\com\tutoringplatform\models\Review.java
======================================================================

package com.tutoringplatform.models;

import java.time.LocalDateTime;
import java.util.UUID;

public class Review {
    private String id;
    private String studentId;
    private String tutorId;
    private int rating;
    private String comment;
    private LocalDateTime timestamp;

    public Review(String studentId, String tutorId, int rating, String comment) {
        this.id = UUID.randomUUID().toString();
        this.studentId = studentId;
        this.tutorId = tutorId;
        setRating(rating);
        this.comment = comment;
        this.timestamp = LocalDateTime.now();
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getStudentId() { return studentId; }
    public void setStudentId(String studentId) { this.studentId = studentId; }

    public String getTutorId() { return tutorId; }
    public void setTutorId(String tutorId) { this.tutorId = tutorId; }

    public int getRating() { return rating; }
    public void setRating(int rating) {
        this.rating = rating;
    }

    public String getComment() { return comment; }
    public void setComment(String comment) { this.comment = comment; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}



======================================================================
// FILE: java\com\tutoringplatform\models\Student.java
======================================================================

package com.tutoringplatform.models;

import java.util.ArrayList;
import java.util.List;

public class Student extends User {
    private List<Review> reviewsGiven;
    private double balance;

    public Student(String name, String email, String password) {
        super(name, email, password, UserType.STUDENT);
        this.reviewsGiven = new ArrayList<>();
        this.balance = 0.0;
    }


    public List<Review> getReviewsGiven() {
        return reviewsGiven;
    }

    public void addReview(Review review) {
        reviewsGiven.add(review);
    }

    public double getBalance() { return balance; }
    public void setBalance(double balance) { this.balance = balance; }
}



======================================================================
// FILE: java\com\tutoringplatform\models\Subject.java
======================================================================

package com.tutoringplatform.models;

import java.util.UUID;

public class Subject {
    private String id;
    private String name;
    private String category;

    public Subject(String name, String category) {
        this.id = UUID.randomUUID().toString();
        this.name = name;
        this.category = category;
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getCategory() { return category; }
    public void setCategory(String category) { this.category = category; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || getClass() != obj.getClass())
            return false;
        Subject subject = (Subject) obj;
        return id.equals(subject.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\Tutor.java
======================================================================

package com.tutoringplatform.models;

import java.util.ArrayList;
import java.util.List;

public class Tutor extends User {
    private List<Subject> subjects;
    private double hourlyRate;
    private String description;
    private List<Review> reviewsReceived;
    private double earnings;

    public Tutor(String name, String email, String password, double hourlyRate, String description) {
        super(name, email, password, UserType.TUTOR);
        this.subjects = new ArrayList<>();
        this.hourlyRate = hourlyRate;
        this.description = description;
        this.reviewsReceived = new ArrayList<>();
        this.earnings = 0.0;
    }

    public List<Subject> getSubjects() {
        return subjects;
    }

    public void addSubject(Subject subject) {
        if (!subjects.contains(subject))
            subjects.add(subject);
    }

    public void removeSubject(Subject subject) {
        subjects.remove(subject);
    }
    
    public List<Review> getReviewsReceived() {
        return reviewsReceived;
    }

    public void addReview(Review review) {
        reviewsReceived.add(review);
    }

    public double getHourlyRate() { return hourlyRate; }
    public void setHourlyRate(double hourlyRate) { this.hourlyRate = hourlyRate; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public double getEarnings() { return earnings; }
    public void setEarnings(double earnings) { this.earnings = earnings; }

}



======================================================================
// FILE: java\com\tutoringplatform\models\User.java
======================================================================

package com.tutoringplatform.models;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.time.ZoneId;

public abstract class User {
    protected String id;
    protected String name;
    protected String email;
    protected String password;
    protected UserType userType;
    protected List<Booking> bookings;
    protected String timeZoneId;
    protected String profilePictureId;

    public User(String name, String email, String password, UserType userType) {
        this.id = UUID.randomUUID().toString();
        this.name = name;
        this.email = email;
        this.password = password;
        this.userType = userType;
        this.bookings = new ArrayList<>();
        this.timeZoneId = ZoneId.systemDefault().getId();
    }

    public void addBooking(Booking booking) {
        bookings.add(booking);
    }

    public void removeBooking(Booking booking) {
        bookings.remove(booking);
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public UserType getUserType() {
        return userType;
    }

    public void setUserType(UserType userType) {
        this.userType = userType;
    }

    public List<Booking> getBookings() {
        return bookings;
    }

    public void setBookings(List<Booking> bookings) {
        this.bookings = bookings;
    }

    public ZoneId getTimeZone() {
        return ZoneId.of(timeZoneId);
    }

    public void setTimeZone(ZoneId timeZone) {
        this.timeZoneId = timeZone.getId();
    }

    public String getTimeZoneId() {
        return timeZoneId;
    }

    public void setTimeZoneId(String timeZoneId) {
        this.timeZoneId = timeZoneId;
    }

    public String getProfilePictureId() {
        return profilePictureId;
    }

    public void setProfilePictureId(String profilePictureId) {
        this.profilePictureId = profilePictureId;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\UserType.java
======================================================================

package com.tutoringplatform.models;

public enum UserType {
    STUDENT("Student"),
    TUTOR("Tutor");
    // Future: ADMIN("Admin")
    
    private final String displayName;
    
    UserType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\availability\AvailabilityException.java
======================================================================

package com.tutoringplatform.models.availability;

import java.time.*;

public class AvailabilityException {
    private Long id;
    private LocalDate startDate;
    private LocalDate endDate;
    private LocalTime startTime; // null means all day
    private LocalTime endTime; // null means all day
    private boolean available; // true = extra availability, false = blackout

    public boolean covers(ZonedDateTime start, ZonedDateTime end) {
        LocalDate date = start.toLocalDate();

        // Check if date is in range
        if (date.isBefore(startDate) || date.isAfter(endDate)) {
            return false;
        }

        // If all-day exception
        if (startTime == null || endTime == null) {
            return true;
        }

        // Check time overlap
        LocalTime requestStart = start.toLocalTime();
        LocalTime requestEnd = end.toLocalTime();

        return !requestEnd.isBefore(startTime) && !requestStart.isAfter(endTime);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDate getStartDate() {
        return startDate;
    }

    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public LocalDate getEndDate() {
        return endDate;
    }

    public void setEndDate(LocalDate endDate) {
        this.endDate = endDate;
    }

    public LocalTime getStartTime() {
        return startTime;
    }

    public void setStartTime(LocalTime startTime) {
        this.startTime = startTime;
    }

    public LocalTime getEndTime() {
        return endTime;
    }

    public void setEndTime(LocalTime endTime) {
        this.endTime = endTime;
    }

    public boolean isAvailable() {
        return available;
    }

    public void setAvailable(boolean available) {
        this.available = available;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\availability\RecurringAvailability.java
======================================================================

package com.tutoringplatform.models.availability;

import java.time.*;

public class RecurringAvailability {
    private Long id;
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public RecurringAvailability(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    public boolean contains(LocalTime requestStart, LocalTime requestEnd) {
        return !requestStart.isBefore(startTime) && !requestEnd.isAfter(endTime);
    }

    // Getters/setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public DayOfWeek getDayOfWeek() {
        return dayOfWeek;
    }

    public LocalTime getStartTime() {
        return startTime;
    }

    public LocalTime getEndTime() {
        return endTime;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\models\availability\TutorAvailability.java
======================================================================

package com.tutoringplatform.models.availability;

import java.time.*;
import java.util.*;

public class TutorAvailability {
    private String tutorId;
    private ZoneId timeZone; // Tutor's time zone
    private List<RecurringAvailability> recurringSlots;
    private List<AvailabilityException> exceptions;

    public TutorAvailability(String tutorId, ZoneId timeZone) {
        this.tutorId = tutorId;
        this.timeZone = timeZone;
        this.recurringSlots = new ArrayList<>();
        this.exceptions = new ArrayList<>();
    }

    // Check availability in the STUDENT's timezone
    public boolean isAvailable(ZonedDateTime requestedStart, ZonedDateTime requestedEnd, ZoneId studentTimeZone) {
        // Convert student's request to tutor's timezone
        ZonedDateTime tutorStart = requestedStart.withZoneSameInstant(timeZone);
        ZonedDateTime tutorEnd = requestedEnd.withZoneSameInstant(timeZone);

        // Check exceptions first (vacations, special unavailability)
        for (AvailabilityException exception : exceptions) {
            if (exception.covers(tutorStart, tutorEnd)) {
                return exception.isAvailable();
            }
        }

        // Check recurring availability
        DayOfWeek dayOfWeek = tutorStart.getDayOfWeek();
        LocalTime startTime = tutorStart.toLocalTime();
        LocalTime endTime = tutorEnd.toLocalTime();

        // Handle sessions that cross midnight
        if (!tutorEnd.toLocalDate().equals(tutorStart.toLocalDate())) {
            // Session spans multiple days - need more complex logic
            return false; // For now, don't allow cross-day bookings
        }

        for (RecurringAvailability slot : recurringSlots) {
            if (slot.getDayOfWeek() == dayOfWeek &&
                    slot.contains(startTime, endTime)) {
                return true;
            }
        }

        return false;
    }

    
    public String getTutorId() {
        return tutorId;
    }

    public ZoneId getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(ZoneId timeZone) {
        this.timeZone = timeZone;
    }

    public List<RecurringAvailability> getRecurringSlots() {
        return recurringSlots;
    }

    public List<AvailabilityException> getExceptions() {
        return exceptions;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\observer\BookingEvent.java
======================================================================

package com.tutoringplatform.observer;

import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;
import org.springframework.context.ApplicationEvent;

public class BookingEvent extends ApplicationEvent {
    private EventType eventType;
    private Booking booking;
    private Student student;
    private Tutor tutor;

    public enum EventType {
        CREATED, CONFIRMED, CANCELLED, COMPLETED
    }

    public BookingEvent(Object source, EventType eventType, Booking booking, Student student, Tutor tutor) {
        super(source);
        this.eventType = eventType;
        this.booking = booking;
        this.student = student;
        this.tutor = tutor;
    }

    public EventType getEventType() {
        return eventType;
    }

    public Booking getBooking() {
        return booking;
    }

    public Student getStudent() {
        return student;
    }

    public Tutor getTutor() {
        return tutor;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\observer\BookingLogger.java
======================================================================

package com.tutoringplatform.observer;

import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import org.springframework.stereotype.Component;
import org.springframework.context.event.EventListener;

@Component
public class BookingLogger {
    private final List<String> logs;
    private final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public BookingLogger() {
        this.logs = new ArrayList<>();
    }

    @EventListener
    public void onBookingEvent(BookingEvent event) {
        String logEntry = String.format("[%s] Booking %s: %s - Student: %s, Tutor: %s, Subject: %s",
                java.time.LocalDateTime.now().format(formatter),
                event.getEventType(),
                event.getBooking().getId(),
                event.getStudent().getName(),
                event.getTutor().getName(),
                event.getBooking().getSubject().getName());

        logs.add(logEntry);
        System.out.println("LOG: " + logEntry);
    }

    public List<String> getLogs() {
        return new ArrayList<>(logs);
    }

    public void printAllLogs() {
        System.out.println("\n=== BOOKING LOGS ===");
        for (String log : logs) {
            System.out.println(log);
        }
        System.out.println("==================\n");
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\AuthenticationRepository.java
======================================================================


package com.tutoringplatform.repositories.impl;

import com.tutoringplatform.models.User;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.IAuthenticationRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

@Repository
public class AuthenticationRepository implements IAuthenticationRepository {

    @Autowired
    private IStudentRepository studentRepository;

    @Autowired
    private ITutorRepository tutorRepository;

    @Override
    public User findByEmail(String email) {
        Student student = studentRepository.findByEmail(email);
        if (student != null)
            return student;

        return tutorRepository.findByEmail(email);
    }

    @Override
    public void saveUser(User user) {
        if (user instanceof Student) {
            studentRepository.save((Student) user);
        } else if (user instanceof Tutor) {
            tutorRepository.save((Tutor) user);
        } else {
            throw new IllegalArgumentException("Unknown user type");
        }
    }

    @Override
    public boolean emailExists(String email) {
        return findByEmail(email) != null;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\AvailabilityRepository.java
======================================================================

// FILE: src/main/java/com/tutoringplatform/repositories/impl/AvailabilityRepository.java
package com.tutoringplatform.repositories.impl;

import com.tutoringplatform.models.availability.TutorAvailability;
import com.tutoringplatform.repositories.interfaces.IAvailabilityRepository;
import org.springframework.stereotype.Repository;
import java.util.HashMap;
import java.util.Map;

@Repository
public class AvailabilityRepository implements IAvailabilityRepository {
    private Map<String, TutorAvailability> availabilities = new HashMap<>();

    @Override
    public TutorAvailability findByTutorId(String tutorId) {
        return availabilities.get(tutorId);
    }

    @Override
    public void save(TutorAvailability availability) {
        availabilities.put(availability.getTutorId(), availability);
    }

    @Override
    public void update(TutorAvailability availability) {
        availabilities.put(availability.getTutorId(), availability);
    }

    @Override
    public void delete(String tutorId) {
        availabilities.remove(tutorId);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\BookingRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Booking;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;

@Repository
public class BookingRepository implements IBookingRepository {
    private Map<String, Booking> bookings = new HashMap<>();

    @Override
    public Booking findById(String id) {
        return bookings.get(id);
    }

    @Override
    public List<Booking> findAll() {
        return new ArrayList<>(bookings.values());
    }

    @Override
    public List<Booking> findByStudentId(String studentId) {
        return bookings.values().stream()
                .filter(b -> b.getStudentId().equals(studentId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByTutorId(String tutorId) {
        return bookings.values().stream()
                .filter(b -> b.getTutorId().equals(tutorId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByStatus(Booking.BookingStatus status) {
        return bookings.values().stream()
                .filter(b -> b.getStatus() == status)
                .collect(Collectors.toList());
    }

    @Override
    public boolean hasCompletedBooking(String studentId, String tutorId) {
        for (Booking booking : bookings.values()) {
            if (booking.getStudentId().equals(studentId) &&
                    booking.getTutorId().equals(tutorId) &&
                    booking.getStatus() == Booking.BookingStatus.COMPLETED) {
                return true;
            }
        }
        return false;
    }

    @Override
    public List<Booking> findByTutorIdAndDateTimeRange(String tutorId, LocalDateTime startTime, LocalDateTime endTime) {
        return bookings.values().stream()
                .filter(b -> b.getTutorId().equals(tutorId) &&
                        b.getDateTime().isAfter(startTime) &&
                        b.getDateTime().isBefore(endTime))
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByTutorIdAndSubjectId(String tutorId, String subjectId) {
        return bookings.values().stream()
                .filter(b -> b.getTutorId().equals(tutorId) &&
                        b.getSubject().getId().equals(subjectId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByStudentIdAndTutorIdAndStatus(String studentId, String tutorId, Booking.BookingStatus status) {
        return bookings.values().stream()
                .filter(b -> b.getStudentId().equals(studentId) &&
                        b.getTutorId().equals(tutorId) &&
                        b.getStatus() == status)
                .collect(Collectors.toList());
    }


    @Override
    public void save(Booking booking) {
        bookings.put(booking.getId(), booking);
    }

    @Override
    public void update(Booking booking) {
        bookings.put(booking.getId(), booking);
    }

    @Override
    public void delete(String id) {
        bookings.remove(id);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\FileRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import com.tutoringplatform.models.FileMetaData;
import com.tutoringplatform.repositories.interfaces.IFileRepository;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class FileRepository implements IFileRepository {
    private Map<String, FileMetaData> files = new HashMap<>();

    @Override
    public FileMetaData findById(String fileId) {
        return files.get(fileId);
    }

    @Override
    public List<FileMetaData> findAll() {
        return new ArrayList<>(files.values());
    }

    @Override
    public List<FileMetaData> findByUserId(String userId) {
        return files.values().stream()
                .filter(f -> f.getUserId().equals(userId))
                .collect(Collectors.toList());
    }

    @Override
    public void save(FileMetaData metadata) {
        files.put(metadata.getFileId(), metadata);
    }

    @Override
    public void update(FileMetaData metadata) {
        files.put(metadata.getFileId(), metadata);
    }

    @Override
    public void delete(String fileId) {
        files.remove(fileId);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\PaymentRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Payment;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;

@Repository
public class PaymentRepository implements IPaymentRepository {
    private Map<String, Payment> payments = new HashMap<>();

    @Override
    public Payment findById(String id) {
        return payments.get(id);
    }

    @Override
    public Payment findByBookingId(String bookingId) {
        return payments.values().stream()
                .filter(p -> p.getBookingId().equals(bookingId))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Payment> findAll() {
        return new ArrayList<>(payments.values());
    }

    @Override
    public void save(Payment payment) {
        payments.put(payment.getId(), payment);
    }

    @Override
    public void update(Payment payment) {
        payments.put(payment.getId(), payment);
    }

    @Override
    public void delete(String id) {
        payments.remove(id);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\ReviewRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Review;
import com.tutoringplatform.repositories.interfaces.IReviewRepository;

@Repository
public class ReviewRepository implements IReviewRepository {
    private Map<String, Review> reviews = new HashMap<>();

    @Override
    public Review findById(String id) {
        return reviews.get(id);
    }

    @Override
    public List<Review> findAll() {
        return new ArrayList<>(reviews.values());
    }

    @Override
    public List<Review> getTutorReviews(String tutorId) {
        return reviews.values().stream()
                .filter(r -> r.getTutorId().equals(tutorId))
                .collect(Collectors.toList());
    }

    @Override
    public List<Review> getStudentReviews(String studentId) {
        return reviews.values().stream()
                .filter(r -> r.getStudentId().equals(studentId))
                .collect(Collectors.toList());
    }

    @Override
    public Review findByStudentIdAndTutorId(String studentId, String tutorId) {
        return reviews.values().stream()
                .filter(r -> r.getStudentId().equals(studentId) && r.getTutorId().equals(tutorId))
                .findFirst()
                .orElse(null);
    }

    @Override
    public void save(Review review) {
        reviews.put(review.getId(), review);
    }

    @Override
    public void update(Review review) {
        reviews.put(review.getId(), review);
    }

    @Override
    public void delete(String id) {
        reviews.remove(id);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\StudentRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Student;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;

@Repository
public class StudentRepository implements IStudentRepository {
    private Map<String, Student> students = new HashMap<>();

    @Override
    public Student findById(String id) {
        return students.get(id);
    }

    @Override
    public Student findByEmail(String email) {
        return students.values().stream()
                .filter(s -> s.getEmail().equals(email))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Student> findAll() {
        return new ArrayList<>(students.values());
    }

    @Override
    public void save(Student student) {
        students.put(student.getId(), student);
    }

    @Override
    public void update(Student student) {
        students.put(student.getId(), student);
    }

    @Override
    public void delete(String id) {
        students.remove(id);
    }

    @Override
    public List<Student> findByNameContaining(String name) {
        return students.values().stream()
                .filter(s -> s.getName().toLowerCase().contains(name.toLowerCase()))
                .collect(Collectors.toList());
    }

    @Override
    public boolean emailExists(String email) {
        return findByEmail(email) != null;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\SubjectRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.repositories.interfaces.ISubjectRepository;

@Repository

public class SubjectRepository implements ISubjectRepository {
    private Map<String, Subject> subjects = new HashMap<>();

    @Override
    public Subject findById(String id) {
        return subjects.get(id);
    }

    @Override
    public Subject findByName(String name) {
        return subjects.values().stream()
                .filter(s -> s.getName().equalsIgnoreCase(name))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Subject> findAll() {
        return new ArrayList<>(subjects.values());
    }

    @Override
    public List<Subject> findByCategory(String category) {
        return subjects.values().stream()
                .filter(s -> s.getCategory().equalsIgnoreCase(category))
                .collect(Collectors.toList());
    }

    @Override
    public void save(Subject subject) {
        subjects.put(subject.getId(), subject);
    }

    @Override
    public void update(Subject subject) {
        subjects.put(subject.getId(), subject);
    }

    @Override
    public void delete(String id) {
        subjects.remove(id);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\impl\TutorRepository.java
======================================================================

package com.tutoringplatform.repositories.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.stereotype.Repository;

import com.tutoringplatform.models.Review;
import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;

@Repository
public class TutorRepository implements ITutorRepository {
    private Map<String, Tutor> tutors = new HashMap<>();

    @Override
    public Tutor findById(String id) {
        return tutors.get(id);
    }

    @Override
    public Tutor findByEmail(String email) {
        return tutors.values().stream()
                .filter(t -> t.getEmail().equals(email))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Tutor> findAll() {
        return new ArrayList<>(tutors.values());
    }

    @Override
    public void save(Tutor tutor) {
        tutors.put(tutor.getId(), tutor);
    }

    @Override
    public void update(Tutor tutor) {
        tutors.put(tutor.getId(), tutor);
    }

    @Override
    public void delete(String id) {
        tutors.remove(id);
    }

    @Override
    public List<Tutor> findBySubject(Subject subject) {
        return tutors.values().stream()
                .filter(t -> t.getSubjects().contains(subject))
                .collect(Collectors.toList());
    }

    @Override
    public List<Tutor> findByHourlyRateBetween(double min, double max) {
        return tutors.values().stream()
                .filter(t -> t.getHourlyRate() >= min && t.getHourlyRate() <= max)
                .collect(Collectors.toList());
    }

    @Override
    public List<Tutor> findByMinimumRating(double rating) {
        return tutors.values().stream()
                .filter(t -> t.getReviewsReceived().stream()
                        .mapToInt(Review::getRating)
                        .average()
                        .orElse(0.0) >= rating)
                .collect(Collectors.toList());
    }

    @Override
    public boolean emailExists(String email) {
        return findByEmail(email) != null;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IAuthenticationRepository.java
======================================================================


package com.tutoringplatform.repositories.interfaces;

import com.tutoringplatform.models.User;

public interface IAuthenticationRepository {
    User findByEmail(String email);

    void saveUser(User user);

    boolean emailExists(String email);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IAvailabilityRepository.java
======================================================================


package com.tutoringplatform.repositories.interfaces;

import com.tutoringplatform.models.availability.TutorAvailability;

public interface IAvailabilityRepository {
    TutorAvailability findByTutorId(String tutorId);

    void save(TutorAvailability availability);

    void update(TutorAvailability availability);

    void delete(String tutorId);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IBookingRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.time.LocalDateTime;
import java.util.List;

import com.tutoringplatform.models.Booking;

public interface IBookingRepository extends IRepository<Booking> {
    List<Booking> findByStudentId(String studentId);
    List<Booking> findByTutorId(String tutorId);
    List<Booking> findByStatus(Booking.BookingStatus status);
    boolean hasCompletedBooking(String studentId, String tutorId);
    List<Booking> findByTutorIdAndDateTimeRange(String tutorId, LocalDateTime startTime, LocalDateTime endTime);
    List<Booking> findByTutorIdAndSubjectId(String tutorId, String subjectId);
    List<Booking> findByStudentIdAndTutorIdAndStatus(String studentId, String tutorId, Booking.BookingStatus status);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IFileRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import com.tutoringplatform.models.FileMetaData;
import java.util.List;

public interface IFileRepository extends IRepository<FileMetaData> {
    List<FileMetaData> findByUserId(String userId);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IPaymentCommand.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import com.tutoringplatform.models.Payment;

public interface IPaymentCommand {
    void execute() throws Exception;
    void undo() throws Exception;
    Payment getPayment();
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IPaymentRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;
import com.tutoringplatform.models.Payment;

public interface IPaymentRepository extends IRepository<Payment> {
    Payment findByBookingId(String bookingId);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

public interface IRepository<T> {
    T findById(String id);
    List<T> findAll();
    void save(T entity);
    void update(T entity);
    void delete(String id);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IReviewRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Review;

public interface IReviewRepository extends IRepository<Review> {
    List<Review> getTutorReviews(String tutorId);
    List<Review> getStudentReviews(String studentId);
    Review findByStudentIdAndTutorId(String studentId, String tutorId);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IStudentRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Student;

public interface IStudentRepository extends IUserRepository<Student> {
    List<Student> findByNameContaining(String name);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\ISubjectRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Subject;

public interface ISubjectRepository extends IRepository<Subject> {
    Subject findByName(String name);
    List<Subject> findByCategory(String category);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\ITutorRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import java.util.List;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;

public interface ITutorRepository extends IUserRepository<Tutor>{
    List<Tutor> findBySubject(Subject subject); 
    List<Tutor> findByHourlyRateBetween(double min, double max);
    List<Tutor> findByMinimumRating(double rating);
}



======================================================================
// FILE: java\com\tutoringplatform\repositories\interfaces\IUserRepository.java
======================================================================

package com.tutoringplatform.repositories.interfaces;

import com.tutoringplatform.models.User;

public interface IUserRepository<T extends User> extends IRepository<T> {
    T findByEmail(String email);
    boolean emailExists(String email);
}



======================================================================
// FILE: java\com\tutoringplatform\services\AuthenticationService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.dto.request.SignupRequest;
import com.tutoringplatform.dto.response.AuthResponse;
import com.tutoringplatform.models.User;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.repositories.interfaces.IAuthenticationRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;
import com.tutoringplatform.factory.UserFactory;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.transaction.annotation.Transactional;
import java.time.ZoneId;

@Service
public class AuthenticationService {

    private final IAuthenticationRepository authenticationRepository;
    private final IStudentRepository studentRepository;
    private final ITutorRepository tutorRepository;
    private final UserFactory userFactory;
    private final PasswordEncoder passwordEncoder;
    private final DTOMapper dtoMapper;

    @Autowired
    public AuthenticationService(
            IAuthenticationRepository authenticationRepository,
            IStudentRepository studentRepository,
            ITutorRepository tutorRepository,
            UserFactory userFactory,
            PasswordEncoder passwordEncoder,
            DTOMapper dtoMapper) {
        this.authenticationRepository = authenticationRepository;
        this.studentRepository = studentRepository;
        this.tutorRepository = tutorRepository;
        this.userFactory = userFactory;
        this.passwordEncoder = passwordEncoder;
        this.dtoMapper = dtoMapper;
    }

    public AuthResponse login(String email, String password) throws Exception {
        // Find user by email
        User user = authenticationRepository.findByEmail(email);
        if (user == null) {
            throw new Exception("Invalid email or password");
        }

        // Verify password
        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new Exception("Invalid email or password");
        }

        // Build response based on user type
        double balance = 0;
        double hourlyRate = 0;

        if (user instanceof Student) {
            balance = ((Student) user).getBalance();
        } else if (user instanceof Tutor) {
            hourlyRate = ((Tutor) user).getHourlyRate();
        }

        return dtoMapper.toAuthResponse(user, balance, hourlyRate);
    }

    @Transactional
    public AuthResponse signup(SignupRequest request) throws Exception {
        // Validate email doesn't exist
        if (authenticationRepository.emailExists(request.getEmail())) {
            throw new Exception("Email already exists");
        }

        // Validate timezone
        ZoneId timeZone;
        try {
            timeZone = request.getTimeZoneId() != null ? ZoneId.of(request.getTimeZoneId()) : ZoneId.systemDefault();
        } catch (Exception e) {
            throw new Exception("Invalid timezone");
        }

        User user;
        double balance = 0;
        double hourlyRate = 0;

        if ("STUDENT".equalsIgnoreCase(request.getUserType())) {
            // Create student
            Student student = userFactory.createStudent(
                    request.getName(),
                    request.getEmail(),
                    passwordEncoder.encode(request.getPassword()));
            student.setTimeZone(timeZone);
            studentRepository.save(student);
            user = student;
            balance = student.getBalance();

        } else if ("TUTOR".equalsIgnoreCase(request.getUserType())) {
            // Validate tutor-specific fields
            if (request.getHourlyRate() <= 0) {
                throw new Exception("Hourly rate must be positive");
            }
            if (request.getDescription() == null || request.getDescription().trim().isEmpty()) {
                throw new Exception("Description is required for tutors");
            }

            // Create tutor
            Tutor tutor = userFactory.createTutor(
                    request.getName(),
                    request.getEmail(),
                    passwordEncoder.encode(request.getPassword()),
                    request.getHourlyRate(),
                    request.getDescription());
            tutor.setTimeZone(timeZone);
            tutorRepository.save(tutor);
            user = tutor;
            hourlyRate = tutor.getHourlyRate();

        } else {
            throw new Exception("Invalid user type. Must be STUDENT or TUTOR");
        }

        return dtoMapper.toAuthResponse(user, balance, hourlyRate);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\AvailabilityService.java
======================================================================

// FILE: src/main/java/com/tutoringplatform/services/AvailabilityService.java
package com.tutoringplatform.services;

import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.models.availability.*;
import com.tutoringplatform.dto.request.TutorAvailabilityRequest;
import com.tutoringplatform.dto.response.AvailabilityResponse;
import com.tutoringplatform.repositories.interfaces.IAvailabilityRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.*;
import java.util.*;

@Service
public class AvailabilityService {

    private final IAvailabilityRepository availabilityRepository;
    private final TutorService tutorService;

    @Autowired
    public AvailabilityService(IAvailabilityRepository availabilityRepository, TutorService tutorService) {
        this.availabilityRepository = availabilityRepository;
        this.tutorService = tutorService;
    }

    public TutorAvailability getAvailability(String tutorId) throws Exception {
        TutorAvailability availability = availabilityRepository.findByTutorId(tutorId);

        if (availability == null) {
            Tutor tutor = tutorService.findById(tutorId);
            availability = new TutorAvailability(tutorId, tutor.getTimeZone());
            availabilityRepository.save(availability);
        }

        return availability;
    }

    public void addRecurringAvailability(String tutorId, DayOfWeek day, LocalTime start, LocalTime end)
            throws Exception {
        TutorAvailability availability = getAvailability(tutorId);

        // Check for overlaps
        for (RecurringAvailability existing : availability.getRecurringSlots()) {
            if (existing.getDayOfWeek() == day) {
                if (!(end.isBefore(existing.getStartTime()) || start.isAfter(existing.getEndTime()))) {
                    throw new IllegalArgumentException("Time slot overlaps with existing availability");
                }
            }
        }

        availability.getRecurringSlots().add(new RecurringAvailability(day, start, end));
        availabilityRepository.update(availability);
    }

    public void removeRecurringAvailability(String tutorId, DayOfWeek day, LocalTime start, LocalTime end)
            throws Exception {
        TutorAvailability availability = getAvailability(tutorId);

        availability.getRecurringSlots().removeIf(slot -> slot.getDayOfWeek() == day &&
                slot.getStartTime().equals(start) &&
                slot.getEndTime().equals(end));

        availabilityRepository.update(availability);
    }

    public void addException(String tutorId, LocalDate startDate, LocalDate endDate,
            LocalTime startTime, LocalTime endTime, boolean available) throws Exception {
        TutorAvailability availability = getAvailability(tutorId);

        AvailabilityException exception = new AvailabilityException();
        exception.setStartDate(startDate);
        exception.setEndDate(endDate);
        exception.setStartTime(startTime);
        exception.setEndTime(endTime);
        exception.setAvailable(available);

        availability.getExceptions().add(exception);
        availabilityRepository.update(availability);
    }

    public boolean isAvailable(String tutorId, ZonedDateTime start, ZonedDateTime end, ZoneId studentTimeZone)
            throws Exception {
        TutorAvailability availability = getAvailability(tutorId);
        return availability.isAvailable(start, end, studentTimeZone);
    }

    public List<String> findAvailableTutors(List<String> tutorIds, ZonedDateTime start, ZonedDateTime end,
            ZoneId studentTimeZone) {
        List<String> available = new ArrayList<>();

        for (String tutorId : tutorIds) {
            try {
                if (isAvailable(tutorId, start, end, studentTimeZone)) {
                    available.add(tutorId);
                }
            } catch (Exception e) {
                // Log error, skip this tutor
            }
        }

        return available;
    }

    // New methods required by TutorController
    public AvailabilityResponse updateTutorAvailability(String tutorId, TutorAvailabilityRequest request) throws Exception {
        if ("ADD".equalsIgnoreCase(request.getAction())) {
            addRecurringAvailability(tutorId, request.getDayOfWeek(), request.getStartTime(), request.getEndTime());
        } else if ("REMOVE".equalsIgnoreCase(request.getAction())) {
            removeRecurringAvailability(tutorId, request.getDayOfWeek(), request.getStartTime(), request.getEndTime());
        } else {
            throw new IllegalArgumentException("Action must be either 'ADD' or 'REMOVE'");
        }

        return getTutorAvailability(tutorId);
    }

    public AvailabilityResponse getTutorAvailability(String tutorId) throws Exception {
        TutorAvailability availability = getAvailability(tutorId);
        
        AvailabilityResponse response = new AvailabilityResponse();
        response.setTutorId(tutorId);
        response.setTimeZone(availability.getTimeZone().getId());
        response.setRegularSchedule(availability.getRecurringSlots());
        response.setExceptions(availability.getExceptions());
        
        // Calculate next available slot (simplified implementation)
        LocalDateTime nextSlot = calculateNextAvailableSlot(availability);
        response.setNextAvailableSlot(nextSlot);
        
        return response;
    }

    private LocalDateTime calculateNextAvailableSlot(TutorAvailability availability) {
        // Simplified implementation - find the next recurring slot from now
        LocalDateTime now = LocalDateTime.now();
        DayOfWeek currentDay = now.getDayOfWeek();
        
        // Look for the next available slot in the recurring schedule
        for (int daysToAdd = 0; daysToAdd < 7; daysToAdd++) {
            DayOfWeek checkDay = currentDay.plus(daysToAdd);
            LocalDate checkDate = now.toLocalDate().plusDays(daysToAdd);
            
            for (RecurringAvailability slot : availability.getRecurringSlots()) {
                if (slot.getDayOfWeek() == checkDay) {
                    LocalDateTime slotDateTime = LocalDateTime.of(checkDate, slot.getStartTime());
                    if (slotDateTime.isAfter(now)) {
                        return slotDateTime;
                    }
                }
            }
        }
        
        // If no slot found in the next week, return null
        return null;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\BookingService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.dto.request.CreateBookingRequest;
import com.tutoringplatform.dto.request.UpdateBookingRequest;
import com.tutoringplatform.dto.response.BookingDetailResponse;
import com.tutoringplatform.dto.response.BookingListResponse;
import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.context.ApplicationEventPublisher;
import com.tutoringplatform.observer.BookingEvent;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.ArrayList;

@Service
public class BookingService {

    private final IBookingRepository bookingRepository;
    private final IStudentRepository studentRepository;
    private final ITutorRepository tutorRepository;
    private final ISubjectRepository subjectRepository;
    private final IPaymentRepository paymentRepository;
    private final AvailabilityService availabilityService;
    private final PaymentService paymentService;
    private final DTOMapper dtoMapper;
    private final ApplicationEventPublisher eventPublisher;

    @Autowired
    public BookingService(
            IBookingRepository bookingRepository,
            IStudentRepository studentRepository,
            ITutorRepository tutorRepository,
            ISubjectRepository subjectRepository,
            IPaymentRepository paymentRepository,
            AvailabilityService availabilityService,
            PaymentService paymentService,
            DTOMapper dtoMapper,
            ApplicationEventPublisher eventPublisher) {
        this.bookingRepository = bookingRepository;
        this.studentRepository = studentRepository;
        this.tutorRepository = tutorRepository;
        this.subjectRepository = subjectRepository;
        this.paymentRepository = paymentRepository;
        this.availabilityService = availabilityService;
        this.paymentService = paymentService;
        this.dtoMapper = dtoMapper;
        this.eventPublisher = eventPublisher;
    }

    @Transactional
    public BookingDetailResponse createBooking(CreateBookingRequest request) throws Exception {
        // Fetch entities
        Student student = studentRepository.findById(request.getStudentId());
        if (student == null) {
            throw new Exception("Student not found");
        }

        Tutor tutor = tutorRepository.findById(request.getTutorId());
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        Subject subject = subjectRepository.findById(request.getSubjectId());
        if (subject == null) {
            throw new Exception("Subject not found");
        }

        // Validate tutor teaches this subject
        if (!tutor.getSubjects().contains(subject)) {
            throw new Exception("Tutor does not teach this subject");
        }

        // Check availability
        ZonedDateTime startTime = request.getDateTime().atZone(student.getTimeZone());
        ZonedDateTime endTime = startTime.plusHours(request.getDurationHours());

        if (!availabilityService.isAvailable(tutor.getId(), startTime, endTime, student.getTimeZone())) {
            throw new Exception("Tutor is not available at this time");
        }

        // Check for conflicts
        List<Booking> existingBookings = bookingRepository.findByTutorIdAndDateTimeRange(
                tutor.getId(),
                request.getDateTime(),
                request.getDateTime().plusHours(request.getDurationHours()));

        if (!existingBookings.isEmpty()) {
            throw new Exception("Time slot already booked");
        }

        // Create booking
        Booking booking = new Booking(
                student.getId(),
                tutor.getId(),
                subject,
                request.getDateTime(),
                request.getDurationHours(),
                tutor.getHourlyRate());

        bookingRepository.save(booking);

        // Publish event
        eventPublisher.publishEvent(new BookingEvent(
                this,
                BookingEvent.EventType.CREATED,
                booking,
                student,
                tutor));

        // Return detailed response - no payment yet as booking is PENDING
        return dtoMapper.toBookingDetailResponse(booking, student, tutor, null);
    }

    public BookingDetailResponse getBookingDetails(String bookingId) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());
        Payment payment = paymentRepository.findByBookingId(bookingId);

        return dtoMapper.toBookingDetailResponse(booking, student, tutor, payment);
    }

    public BookingListResponse getStudentBookingList(String studentId) throws Exception {
        Student student = studentRepository.findById(studentId);
        if (student == null) {
            throw new Exception("Student not found");
        }

        List<Booking> allBookings = bookingRepository.findByStudentId(studentId);
        return categorizeAndEnrichBookings(allBookings);
    }

    public BookingListResponse getTutorBookingList(String tutorId) throws Exception {
        Tutor tutor = tutorRepository.findById(tutorId);
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        List<Booking> allBookings = bookingRepository.findByTutorId(tutorId);
        return categorizeAndEnrichBookings(allBookings);
    }

    @Transactional
    public BookingDetailResponse updateBooking(String bookingId, UpdateBookingRequest request) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() != Booking.BookingStatus.PENDING) {
            throw new Exception("Can only update pending bookings");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());

        // Update date/time if provided
        if (request.getDateTime() != null) {
            // Check new time availability
            ZonedDateTime startTime = request.getDateTime().atZone(student.getTimeZone());
            ZonedDateTime endTime = startTime.plusHours(
                    request.getDurationHours() != 0 ? request.getDurationHours() : booking.getDurationHours());

            if (!availabilityService.isAvailable(tutor.getId(), startTime, endTime, student.getTimeZone())) {
                throw new Exception("Tutor is not available at the new time");
            }

            booking.setDateTime(request.getDateTime());
        }

        // Update duration if provided
        if (request.getDurationHours() != 0) {
            booking.setDurationHours(request.getDurationHours());
            booking.setTotalCost(tutor.getHourlyRate() * request.getDurationHours());
        }

        bookingRepository.update(booking);

        return dtoMapper.toBookingDetailResponse(booking, student, tutor, null);
    }

    @Transactional
    public BookingDetailResponse confirmBooking(String bookingId) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() != Booking.BookingStatus.PENDING) {
            throw new Exception("Booking is not in pending status");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());

        // Process payment
        Payment payment = paymentService.processPayment(
                student.getId(),
                bookingId,
                booking.getTotalCost());

        // Update booking
        booking.setPayment(payment);
        booking.setStatus(Booking.BookingStatus.CONFIRMED);
        bookingRepository.update(booking);

        // Update user bookings
        student.addBooking(booking);
        tutor.addBooking(booking);
        studentRepository.update(student);
        tutorRepository.update(tutor);

        // Publish event
        eventPublisher.publishEvent(new BookingEvent(
                this,
                BookingEvent.EventType.CONFIRMED,
                booking,
                student,
                tutor));

        return dtoMapper.toBookingDetailResponse(booking, student, tutor, payment);
    }

    @Transactional
    public void cancelBooking(String bookingId) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() == Booking.BookingStatus.COMPLETED) {
            throw new Exception("Cannot cancel completed booking");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());

        // If confirmed, process refund
        if (booking.getStatus() == Booking.BookingStatus.CONFIRMED && booking.getPayment() != null) {
            paymentService.refundPayment(booking.getPayment().getId());
        }

        // Update status
        booking.setStatus(Booking.BookingStatus.CANCELLED);
        bookingRepository.update(booking);

        // Remove from user bookings
        student.removeBooking(booking);
        tutor.removeBooking(booking);
        studentRepository.update(student);
        tutorRepository.update(tutor);

        // Publish event
        eventPublisher.publishEvent(new BookingEvent(
                this,
                BookingEvent.EventType.CANCELLED,
                booking,
                student,
                tutor));
    }

    @Transactional
    public void completeBooking(String bookingId) throws Exception {
        Booking booking = bookingRepository.findById(bookingId);
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        if (booking.getStatus() != Booking.BookingStatus.CONFIRMED) {
            throw new Exception("Booking must be confirmed first");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        Tutor tutor = tutorRepository.findById(booking.getTutorId());

        // Update status
        booking.setStatus(Booking.BookingStatus.COMPLETED);
        bookingRepository.update(booking);

        // Add earnings to tutor
        tutor.setEarnings(tutor.getEarnings() + booking.getTotalCost());
        tutorRepository.update(tutor);

        // Publish event
        eventPublisher.publishEvent(new BookingEvent(
                this,
                BookingEvent.EventType.COMPLETED,
                booking,
                student,
                tutor));
    }

    // Helper method to categorize and enrich bookings
    private BookingListResponse categorizeAndEnrichBookings(List<Booking> bookings) throws Exception {
        LocalDateTime now = LocalDateTime.now();
        List<BookingDetailResponse> upcomingBookings = new ArrayList<>();
        List<BookingDetailResponse> pastBookings = new ArrayList<>();
        List<BookingDetailResponse> cancelledBookings = new ArrayList<>();

        for (Booking booking : bookings) {
            Student student = studentRepository.findById(booking.getStudentId());
            Tutor tutor = tutorRepository.findById(booking.getTutorId());
            Payment payment = paymentRepository.findByBookingId(booking.getId());

            BookingDetailResponse detail = dtoMapper.toBookingDetailResponse(
                    booking, student, tutor, payment);

            if (booking.getStatus() == Booking.BookingStatus.CANCELLED) {
                cancelledBookings.add(detail);
            } else if (booking.getDateTime().isAfter(now)) {
                upcomingBookings.add(detail);
            } else {
                pastBookings.add(detail);
            }
        }

        return dtoMapper.toBookingListResponse(upcomingBookings, pastBookings, cancelledBookings);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\DashboardService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.dto.response.*;
import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.LocalDate;
import java.util.List;
import java.util.ArrayList;

@Service
public class DashboardService {

    private final IStudentRepository studentRepository;
    private final ITutorRepository tutorRepository;
    private final IBookingRepository bookingRepository;
    private final IReviewRepository reviewRepository;
    private final IPaymentRepository paymentRepository;
    private final DTOMapper dtoMapper;

    @Autowired
    public DashboardService(
            IStudentRepository studentRepository,
            ITutorRepository tutorRepository,
            IBookingRepository bookingRepository,
            IReviewRepository reviewRepository,
            IPaymentRepository paymentRepository,
            DTOMapper dtoMapper) {
        this.studentRepository = studentRepository;
        this.tutorRepository = tutorRepository;
        this.bookingRepository = bookingRepository;
        this.reviewRepository = reviewRepository;
        this.paymentRepository = paymentRepository;
        this.dtoMapper = dtoMapper;
    }

    public StudentDashboardResponse getStudentDashboard(String studentId) throws Exception {
        // Fetch student
        Student student = studentRepository.findById(studentId);
        if (student == null) {
            throw new Exception("Student not found");
        }

        // Build profile
        UserProfile profile = new UserProfile();
        profile.setName(student.getName());
        profile.setBalance(student.getBalance());
        profile.setProfilePictureUrl(dtoMapper.buildProfilePictureUrl(student.getProfilePictureId()));

        // Build stats
        List<Booking> allBookings = bookingRepository.findByStudentId(studentId);
        DashboardStats stats = buildStudentStats(allBookings);

        // Get upcoming bookings with details
        LocalDateTime now = LocalDateTime.now();
        List<BookingDetailResponse> upcomingBookings = new ArrayList<>();

        for (Booking booking : allBookings) {
            if (booking.getDateTime().isAfter(now) &&
                    booking.getStatus() != Booking.BookingStatus.CANCELLED) {

                Tutor tutor = tutorRepository.findById(booking.getTutorId());
                Payment payment = paymentRepository.findByBookingId(booking.getId());

                BookingDetailResponse detail = dtoMapper.toBookingDetailResponse(
                        booking, student, tutor, payment);
                upcomingBookings.add(detail);
            }
        }

        // Sort by date
        upcomingBookings.sort((a, b) -> a.getDateTime().compareTo(b.getDateTime()));

        return dtoMapper.toStudentDashboardResponse(profile, stats, upcomingBookings);
    }

    public TutorDashboardResponse getTutorDashboard(String tutorId) throws Exception {
        // Fetch tutor
        Tutor tutor = tutorRepository.findById(tutorId);
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        // Build profile
        UserProfile profile = new UserProfile();
        profile.setName(tutor.getName());
        profile.setHourlyRate(tutor.getHourlyRate());
        profile.setProfilePictureUrl(dtoMapper.buildProfilePictureUrl(tutor.getProfilePictureId()));

        // Build stats
        List<Booking> allBookings = bookingRepository.findByTutorId(tutorId);
        List<Review> allReviews = reviewRepository.getTutorReviews(tutorId);
        DashboardStats stats = buildTutorStats(allBookings, allReviews, tutor.getEarnings());

        // Get upcoming bookings
        LocalDateTime now = LocalDateTime.now();
        List<BookingDetailResponse> upcomingBookings = new ArrayList<>();
        List<BookingDetailResponse> todaysSchedule = new ArrayList<>();

        for (Booking booking : allBookings) {
            if (booking.getDateTime().isAfter(now) &&
                    booking.getStatus() != Booking.BookingStatus.CANCELLED) {

                Student student = studentRepository.findById(booking.getStudentId());
                Payment payment = paymentRepository.findByBookingId(booking.getId());

                BookingDetailResponse detail = dtoMapper.toBookingDetailResponse(
                        booking, student, tutor, payment);

                upcomingBookings.add(detail);

                // Check if it's today
                if (booking.getDateTime().toLocalDate().equals(LocalDate.now())) {
                    todaysSchedule.add(detail);
                }
            }
        }

        // Sort by date
        upcomingBookings.sort((a, b) -> a.getDateTime().compareTo(b.getDateTime()));
        todaysSchedule.sort((a, b) -> a.getDateTime().compareTo(b.getDateTime()));

        return dtoMapper.toTutorDashboardResponse(profile, stats, upcomingBookings, null, todaysSchedule);
    }

    private DashboardStats buildStudentStats(List<Booking> bookings) {
        DashboardStats stats = new DashboardStats();

        int totalSessions = bookings.size();
        int completedSessions = (int) bookings.stream()
                .filter(b -> b.getStatus() == Booking.BookingStatus.COMPLETED)
                .count();
        int upcomingSessions = (int) bookings.stream()
                .filter(b -> b.getStatus() != Booking.BookingStatus.CANCELLED &&
                        b.getDateTime().isAfter(LocalDateTime.now()))
                .count();

        stats.setTotalSessions(totalSessions);
        stats.setCompletedSessions(completedSessions);
        stats.setUpcomingSessions(upcomingSessions);

        return stats;
    }

    private DashboardStats buildTutorStats(List<Booking> bookings, List<Review> reviews, double totalEarnings) {
        DashboardStats stats = new DashboardStats();

        // Booking stats
        int totalSessions = bookings.size();
        int completedSessions = (int) bookings.stream()
                .filter(b -> b.getStatus() == Booking.BookingStatus.COMPLETED)
                .count();
        int upcomingSessions = (int) bookings.stream()
                .filter(b -> b.getStatus() != Booking.BookingStatus.CANCELLED &&
                        b.getDateTime().isAfter(LocalDateTime.now()))
                .count();

        // This month's earnings
        LocalDate startOfMonth = LocalDate.now().withDayOfMonth(1);
        double thisMonthEarnings = bookings.stream()
                .filter(b -> b.getStatus() == Booking.BookingStatus.COMPLETED &&
                        b.getDateTime().toLocalDate().isAfter(startOfMonth.minusDays(1)))
                .mapToDouble(Booking::getTotalCost)
                .sum();

        // Review stats
        double averageRating = reviews.isEmpty() ? 0.0
                : reviews.stream()
                        .mapToDouble(Review::getRating)
                        .average()
                        .orElse(0.0);

        stats.setTotalSessions(totalSessions);
        stats.setCompletedSessions(completedSessions);
        stats.setUpcomingSessions(upcomingSessions);
        stats.setTotalEarnings(totalEarnings);
        stats.setThisMonthEarnings(thisMonthEarnings);
        stats.setAverageRating(averageRating);
        stats.setTotalReviews(reviews.size());

        return stats;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\FileService.java
======================================================================

// FILE: src/main/java/com/tutoringplatform/services/FileService.java
package com.tutoringplatform.services;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import com.tutoringplatform.models.FileMetaData;
import com.tutoringplatform.repositories.interfaces.IFileRepository;
import org.springframework.beans.factory.annotation.Autowired;
import java.nio.file.*;
import java.util.*;

@Service
public class FileService {

    private final IFileRepository fileRepository;
    private final Path fileStorageLocation = Paths.get("uploads").toAbsolutePath().normalize();

    @Autowired
    public FileService(IFileRepository fileRepository) {
        this.fileRepository = fileRepository;
        try {
            Files.createDirectories(this.fileStorageLocation);
        } catch (Exception ex) {
            throw new RuntimeException("Could not create upload directory");
        }
    }

    public String storeFile(String userId, MultipartFile file, String fileType) throws Exception {
        // Validate file
        String fileName = file.getOriginalFilename();
        if (fileName == null || fileName.contains("..")) {
            throw new Exception("Invalid file name");
        }

        // Validate file type
        String contentType = file.getContentType();
        if (!isAllowedFileType(fileType, contentType)) {
            throw new Exception("File type not allowed");
        }

        // Generate unique file ID
        String fileId = UUID.randomUUID().toString();
        String extension = fileName.substring(fileName.lastIndexOf("."));
        String storedFileName = fileId + extension;

        // Store file
        Path targetLocation = this.fileStorageLocation.resolve(storedFileName);
        Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);

        // Store metadata
        FileMetaData metadata = new FileMetaData(fileId, userId, fileName, fileType, storedFileName);
        fileRepository.save(metadata);

        return fileId;
    }

    public Resource loadFile(String fileId) throws Exception {
        FileMetaData metadata = fileRepository.findById(fileId);
        if (metadata == null) {
            throw new Exception("File not found");
        }

        Path filePath = this.fileStorageLocation.resolve(metadata.getStoredFileName()).normalize();
        Resource resource = new UrlResource(filePath.toUri());

        if (!resource.exists()) {
            throw new Exception("File not found");
        }

        return resource;
    }

    public void deleteFile(String fileId) throws Exception {
        FileMetaData metadata = fileRepository.findById(fileId);
        if (metadata == null) {
            throw new Exception("File not found");
        }

        Path filePath = this.fileStorageLocation.resolve(metadata.getStoredFileName()).normalize();
        Files.deleteIfExists(filePath);

        fileRepository.delete(fileId);
    }

    private boolean isAllowedFileType(String fileType, String contentType) {
        switch (fileType) {
            case "profile":
                return contentType != null && (contentType.equals("image/jpeg") ||
                        contentType.equals("image/png") ||
                        contentType.equals("image/jpg"));
            default:
                return false;
        }
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\PaymentService.java
======================================================================

package com.tutoringplatform.services;

import java.util.Stack;

import com.tutoringplatform.command.ProcessPaymentCommand;
import com.tutoringplatform.command.RefundPaymentCommand;
import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Payment;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.dto.response.PaymentHistoryResponse;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;
import com.tutoringplatform.repositories.interfaces.IPaymentCommand;
import com.tutoringplatform.repositories.interfaces.IPaymentRepository;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.util.DTOMapper;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;

@Service
public class PaymentService {
    private final IPaymentRepository paymentRepository;
    private final IStudentRepository studentRepository;
    private final IBookingRepository bookingRepository;
    private final Stack<IPaymentCommand> commandHistory;
    private final DTOMapper dtoMapper;
    @Autowired
    public PaymentService(IPaymentRepository paymentRepository, IStudentRepository studentRepository,
            IBookingRepository bookingRepository, DTOMapper dtoMapper) {
        this.paymentRepository = paymentRepository;
        this.studentRepository = studentRepository;
        this.bookingRepository = bookingRepository;
        this.commandHistory = new Stack<>();
        this.dtoMapper = dtoMapper;
    }

    @Transactional
    public Payment processPayment(String studentId, String bookingId, double amount) throws Exception {
        Student student = studentRepository.findById(studentId);
        if (student == null) {
            throw new Exception("Student not found");
        }

        Payment payment = new Payment(bookingId, amount);

        ProcessPaymentCommand command = new ProcessPaymentCommand(
                payment, student, amount, paymentRepository, studentRepository);

        command.execute();
        commandHistory.push(command);

        return payment;
    }

    @Transactional
    public void refundPayment(String paymentId) throws Exception {
        Payment payment = paymentRepository.findById(paymentId);
        if (payment == null) {
            throw new Exception("Payment not found");
        }

        Booking booking = bookingRepository.findById(payment.getBookingId());
        if (booking == null) {
            throw new Exception("Booking not found");
        }

        Student student = studentRepository.findById(booking.getStudentId());
        if (student == null) {
            throw new Exception("Student not found");
        }

        RefundPaymentCommand command = new RefundPaymentCommand(
                payment, student, payment.getAmount(), paymentRepository, studentRepository);

        command.execute();
        commandHistory.push(command);
    }

    public void undoLastPaymentAction() throws Exception {
        if (commandHistory.isEmpty()) {
            throw new Exception("No payment action to undo");
        }

        IPaymentCommand lastCommand = commandHistory.pop();
        lastCommand.undo();
    }

    public Payment findById(String id) throws Exception {
        Payment payment = paymentRepository.findById(id);
        if (payment == null) {
            throw new Exception("Payment not found");
        }
        return payment;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\ReviewService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.dto.request.CreateReviewRequest;
import com.tutoringplatform.dto.response.ReviewResponse;
import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;
import java.util.ArrayList;

@Service
public class ReviewService {

    private final IReviewRepository reviewRepository;
    private final IBookingRepository bookingRepository;
    private final IStudentRepository studentRepository;
    private final ITutorRepository tutorRepository;
    private final DTOMapper dtoMapper;

    @Autowired
    public ReviewService(
            IReviewRepository reviewRepository,
            IBookingRepository bookingRepository,
            IStudentRepository studentRepository,
            ITutorRepository tutorRepository,
            DTOMapper dtoMapper) {
        this.reviewRepository = reviewRepository;
        this.bookingRepository = bookingRepository;
        this.studentRepository = studentRepository;
        this.tutorRepository = tutorRepository;
        this.dtoMapper = dtoMapper;
    }

    @Transactional
    public ReviewResponse createReview(CreateReviewRequest request) throws Exception {
        // Extract student and tutor IDs from request
        String studentId = request.getStudentId();
        String tutorId = request.getTutorId();

        // Verify student exists
        Student student = studentRepository.findById(studentId);
        if (student == null) {
            throw new Exception("Student not found");
        }

        // Verify tutor exists
        Tutor tutor = tutorRepository.findById(tutorId);
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        // Check if student has completed any bookings with this tutor
        List<Booking> completedBookings = bookingRepository.findByStudentIdAndTutorIdAndStatus(
                studentId, tutorId, Booking.BookingStatus.COMPLETED);

        if (completedBookings.isEmpty()) {
            throw new Exception("Can only review tutors you've had completed sessions with");
        }

        // Check if review already exists from this student for this tutor
        Review existingReview = reviewRepository.findByStudentIdAndTutorId(studentId, tutorId);

        if (existingReview != null) {
            // Update existing review
            existingReview.setRating(request.getRating());
            existingReview.setComment(request.getComment());
            existingReview.setTimestamp(LocalDateTime.now());
            reviewRepository.update(existingReview);

            return dtoMapper.toReviewResponse(existingReview, student, tutor);
        }

        // Validate rating
        if (request.getRating() < 1 || request.getRating() > 5) {
            throw new Exception("Rating must be between 1 and 5");
        }

        // Create new review
        Review review = new Review(
                studentId,
                tutorId,
                request.getRating(),
                request.getComment());

        reviewRepository.save(review);

        // Update tutor's reviews list
        tutor.getReviewsReceived().add(review);
        tutorRepository.update(tutor);

        // Update student's reviews list
        student.getReviewsGiven().add(review);
        studentRepository.update(student);

        return dtoMapper.toReviewResponse(review, student, tutor);
    }

    public List<ReviewResponse> getTutorReviewsWithDetails(String tutorId) throws Exception {
        Tutor tutor = tutorRepository.findById(tutorId);
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        List<Review> reviews = reviewRepository.getTutorReviews(tutorId);
        List<ReviewResponse> responses = new ArrayList<>();

        for (Review review : reviews) {
            Student student = studentRepository.findById(review.getStudentId());

            ReviewResponse response = dtoMapper.toReviewResponse(review, student, tutor);
            responses.add(response);
        }

        // Sort by most recent first
        responses.sort((a, b) -> b.getCreatedAt().compareTo(a.getCreatedAt()));

        return responses;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\SearchService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.models.availability.TutorAvailability;
import com.tutoringplatform.dto.request.TutorSearchRequest;
import com.tutoringplatform.dto.response.*;
import com.tutoringplatform.dto.response.info.TutorSearchResultInfo;
import com.tutoringplatform.models.*;
import com.tutoringplatform.repositories.interfaces.*;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class SearchService {

    private final ITutorRepository tutorRepository;
    private final ISubjectRepository subjectRepository;
    private final IReviewRepository reviewRepository;
    private final IBookingRepository bookingRepository;
    private final AvailabilityService availabilityService;
    private final DTOMapper dtoMapper;

    @Autowired
    public SearchService(
            ITutorRepository tutorRepository,
            ISubjectRepository subjectRepository,
            IReviewRepository reviewRepository,
            IBookingRepository bookingRepository,
            AvailabilityService availabilityService,
            DTOMapper dtoMapper) {
        this.tutorRepository = tutorRepository;
        this.subjectRepository = subjectRepository;
        this.reviewRepository = reviewRepository;
        this.bookingRepository = bookingRepository;
        this.availabilityService = availabilityService;
        this.dtoMapper = dtoMapper;
    }

    public TutorSearchResultsResponse searchTutors(TutorSearchRequest request) throws Exception {
        // Start with all tutors
        List<Tutor> tutors = tutorRepository.findAll();

        // Apply filters
        tutors = applyFilters(tutors, request);

        // Sort results
        tutors = sortResults(tutors, request.getSortBy());

        // Apply pagination
        int page = request.getPage() != null ? request.getPage() : 0;
        int pageSize = request.getPageSize() != null ? request.getPageSize() : 20;
        int totalCount = tutors.size();

        int startIndex = page * pageSize;
        int endIndex = Math.min(startIndex + pageSize, tutors.size());

        List<Tutor> paginatedTutors = startIndex < tutors.size() ? tutors.subList(startIndex, endIndex)
                : new ArrayList<>();

        // Convert to search results
        List<TutorSearchResultInfo> results = new ArrayList<>();
        for (Tutor tutor : paginatedTutors) {
            TutorSearchResultInfo result = buildSearchResult(tutor);
            results.add(result);
        }

        // Build filters for response
        SearchFilters appliedFilters = new SearchFilters();
        appliedFilters.setSubjectId(request.getSubjectId());
        appliedFilters.setMinPrice(request.getMinPrice());
        appliedFilters.setMaxPrice(request.getMaxPrice());
        appliedFilters.setMinRating(request.getMinRating());
        appliedFilters.setSortBy(request.getSortBy());

        return dtoMapper.toTutorSearchResultsResponse(results, totalCount, appliedFilters);
    }

    private List<Tutor> applyFilters(List<Tutor> tutors, TutorSearchRequest request) throws Exception {
        // Filter by subject
        if (request.getSubjectId() != null) {
            Subject subject = subjectRepository.findById(request.getSubjectId());
            if (subject != null) {
                tutors = tutors.stream()
                        .filter(t -> t.getSubjects().contains(subject))
                        .collect(Collectors.toList());
            }
        }

        // Filter by price range
        if (request.getMinPrice() > 0) {
            tutors = tutors.stream()
                    .filter(t -> t.getHourlyRate() >= request.getMinPrice())
                    .collect(Collectors.toList());
        }

        if (request.getMaxPrice() > 0) {
            tutors = tutors.stream()
                    .filter(t -> t.getHourlyRate() <= request.getMaxPrice())
                    .collect(Collectors.toList());
        }

        // Filter by minimum rating
        if (request.getMinRating() > 0) {
            tutors = tutors.stream()
                    .filter(t -> {
                        double avgRating = calculateAverageRating(t.getId());
                        return avgRating >= request.getMinRating();
                    })
                    .collect(Collectors.toList());
        }

        // Filter by search text
        if (request.getSearchText() != null && !request.getSearchText().trim().isEmpty()) {
            String searchLower = request.getSearchText().toLowerCase();
            tutors = tutors.stream()
                    .filter(t -> t.getName().toLowerCase().contains(searchLower) ||
                            t.getDescription().toLowerCase().contains(searchLower) ||
                            t.getSubjects().stream()
                                    .anyMatch(s -> s.getName().toLowerCase().contains(searchLower)))
                    .collect(Collectors.toList());
        }

        // Filter by availability
        if (request.getAvailableNow() != null && request.getAvailableNow()) {
            tutors = filterByCurrentAvailability(tutors);
        } else if (request.getAvailableDateTime() != null) {
            tutors = filterBySpecificAvailability(tutors, request.getAvailableDateTime());
        }

        return tutors;
    }

    private List<Tutor> filterByCurrentAvailability(List<Tutor> tutors) {
        ZoneId userTimeZone = ZoneId.systemDefault(); // Should get from user context
        ZonedDateTime now = ZonedDateTime.now(userTimeZone);
        ZonedDateTime oneHourLater = now.plusHours(1);

        return tutors.stream()
                .filter(tutor -> {
                    try {
                        return availabilityService.isAvailable(
                                tutor.getId(), now, oneHourLater, userTimeZone);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .collect(Collectors.toList());
    }

    private List<Tutor> filterBySpecificAvailability(List<Tutor> tutors, LocalDateTime dateTime) {
        ZoneId userTimeZone = ZoneId.systemDefault(); // Should get from user context
        ZonedDateTime start = dateTime.atZone(userTimeZone);
        ZonedDateTime end = start.plusHours(1); // Default 1 hour session

        return tutors.stream()
                .filter(tutor -> {
                    try {
                        return availabilityService.isAvailable(
                                tutor.getId(), start, end, userTimeZone);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .collect(Collectors.toList());
    }

    private List<Tutor> sortResults(List<Tutor> tutors, String sortBy) {
        if (sortBy == null) {
            sortBy = "RATING"; // Default sort
        }

        switch (sortBy) {
            case "PRICE_LOW":
                tutors.sort(Comparator.comparing(Tutor::getHourlyRate));
                break;
            case "PRICE_HIGH":
                tutors.sort(Comparator.comparing(Tutor::getHourlyRate).reversed());
                break;
            case "RATING":
                tutors.sort((a, b) -> {
                    double ratingA = calculateAverageRating(a.getId());
                    double ratingB = calculateAverageRating(b.getId());
                    return Double.compare(ratingB, ratingA); // Descending
                });
                break;
            case "REVIEWS":
                tutors.sort((a, b) -> {
                    int reviewsA = reviewRepository.getTutorReviews(a.getId()).size();
                    int reviewsB = reviewRepository.getTutorReviews(b.getId()).size();
                    return Integer.compare(reviewsB, reviewsA); // Descending
                });
                break;
        }

        return tutors;
    }

    private TutorSearchResultInfo buildSearchResult(Tutor tutor) throws Exception {
        // Calculate average rating
        double averageRating = calculateAverageRating(tutor.getId());

        // Get review count
        int reviewCount = reviewRepository.getTutorReviews(tutor.getId()).size();

        // Create short description (first 100 chars)
        String shortDescription = tutor.getDescription();
        if (shortDescription.length() > 100) {
            shortDescription = shortDescription.substring(0, 97) + "...";
        }

        // Find next available slot
        LocalDateTime nextAvailable = findNextAvailableSlot(tutor.getId());

        return dtoMapper.toTutorSearchResult(
                tutor,
                averageRating,
                reviewCount,
                shortDescription,
                nextAvailable);
    }

    private double calculateAverageRating(String tutorId) {
        List<Review> reviews = reviewRepository.getTutorReviews(tutorId);
        if (reviews.isEmpty()) {
            return 0.0;
        }

        return reviews.stream()
                .mapToDouble(Review::getRating)
                .average()
                .orElse(0.0);
    }

    private LocalDateTime findNextAvailableSlot(String tutorId) throws Exception {
        // Get tutor's availability
        TutorAvailability availability = availabilityService.getAvailability(tutorId);
        if (availability.getRecurringSlots().isEmpty()) {
            return null;
        }

        // Get existing bookings
        List<Booking> bookings = bookingRepository.findByTutorId(tutorId).stream()
                .filter(b -> b.getStatus() != Booking.BookingStatus.CANCELLED)
                .filter(b -> b.getDateTime().isAfter(LocalDateTime.now()))
                .collect(Collectors.toList());

        // Find next available slot (simplified - would need more complex logic)
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime checkTime = now.plusHours(1); // Start checking from 1 hour from now

        // Check next 7 days
        for (int i = 0; i < 168; i++) { // 168 hours = 7 days
            LocalDateTime slotTime = checkTime.plusHours(i);
            ZonedDateTime slotStart = slotTime.atZone(availability.getTimeZone());
            ZonedDateTime slotEnd = slotStart.plusHours(1);

            // Check if this slot is available
            boolean isAvailable = availabilityService.isAvailable(
                    tutorId, slotStart, slotEnd, availability.getTimeZone());

            if (isAvailable) {
                // Check if not already booked
                boolean isBooked = bookings.stream()
                        .anyMatch(b -> {
                            LocalDateTime bookingEnd = b.getDateTime().plusHours(b.getDurationHours());
                            return !slotTime.isAfter(bookingEnd) && !slotTime.plusHours(1).isBefore(b.getDateTime());
                        });

                if (!isBooked) {
                    return slotTime;
                }
            }
        }

        return null;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\StudentService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.dto.request.UpdateProfileRequest;
import com.tutoringplatform.dto.response.StudentProfileResponse;
import com.tutoringplatform.dto.response.ValueResponse;
import com.tutoringplatform.models.Student;
import com.tutoringplatform.models.Booking;
import com.tutoringplatform.repositories.interfaces.IStudentRepository;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.multipart.MultipartFile;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@Service
public class StudentService extends UserService<Student> {

    private final IBookingRepository bookingRepository;
    private final FileService fileService;
    private final PasswordEncoder passwordEncoder;
    private final DTOMapper dtoMapper;

    @Autowired
    public StudentService(
            IStudentRepository studentRepository,
            IBookingRepository bookingRepository,
            FileService fileService,
            PasswordEncoder passwordEncoder,
            DTOMapper dtoMapper) {
        super(studentRepository);
        this.bookingRepository = bookingRepository;
        this.fileService = fileService;
        this.passwordEncoder = passwordEncoder;
        this.dtoMapper = dtoMapper;
    }

    public StudentProfileResponse getStudentProfile(String studentId) throws Exception {
        Student student = findById(studentId);

        // Calculate joined date (would normally come from audit fields)
        LocalDate joinedDate = LocalDate.now().minusYears(1); // Placeholder

        // Count total sessions
        List<Booking> bookings = bookingRepository.findByStudentId(studentId);
        int totalSessions = bookings.size();

        return dtoMapper.toStudentProfileResponse(student, joinedDate, totalSessions);
    }

    @Transactional
    public StudentProfileResponse updateStudentProfile(String studentId, UpdateProfileRequest request)
            throws Exception {
        Student student = findById(studentId);

        // Update name if provided
        if (request.getName() != null && !request.getName().trim().isEmpty()) {
            student.setName(request.getName());
        }

        // Update email if provided and not taken
        if (request.getEmail() != null && !request.getEmail().isEmpty()) {
            Student existing = repository.findByEmail(request.getEmail());
            if (existing != null && !existing.getId().equals(studentId)) {
                throw new Exception("Email already in use");
            }
            student.setEmail(request.getEmail());
        }

        // Update password if provided with current password verification
        if (request.getPassword() != null && !request.getPassword().isEmpty()) {
            if (request.getCurrentPassword() == null || request.getCurrentPassword().isEmpty()) {
                throw new Exception("Current password required to change password");
            }

            if (!passwordEncoder.matches(request.getCurrentPassword(), student.getPassword())) {
                throw new Exception("Current password is incorrect");
            }

            student.setPassword(passwordEncoder.encode(request.getPassword()));
        }

        // Update timezone if provided
        if (request.getTimeZoneId() != null) {
            try {
                ZoneId zone = ZoneId.of(request.getTimeZoneId());
                student.setTimeZone(zone);
            } catch (Exception e) {
                throw new Exception("Invalid timezone");
            }
        }

        repository.update(student);

        return getStudentProfile(studentId);
    }

    @Transactional
    public Map<String, String> updateProfilePicture(String studentId, MultipartFile file) throws Exception {
        Student student = findById(studentId);

        // Delete old profile picture if exists
        if (student.getProfilePictureId() != null) {
            try {
                fileService.deleteFile(student.getProfilePictureId());
            } catch (Exception e) {
                // Log error but continue
            }
        }

        // Store new profile picture
        String fileId = fileService.storeFile(studentId, file, "profile");
        student.setProfilePictureId(fileId);
        repository.update(student);

        Map<String, String> result = new HashMap<>();
        result.put("profilePictureId", fileId);
        result.put("profilePictureUrl", "/api/files/" + fileId);

        return result;
    }

    @Transactional
    public ValueResponse<Double> addFunds(String studentId, double amount) throws Exception {
        if (amount <= 0) {
            throw new Exception("Amount must be positive");
        }

        Student student = findById(studentId);
        double newBalance = student.getBalance() + amount;
        student.setBalance(newBalance);
        repository.update(student);

        // Log transaction (would normally create a transaction record)
        // transactionService.createDeposit(studentId, amount);

        return dtoMapper.toValueResponse(newBalance);
    }

    public ValueResponse<Double> getBalance(String studentId) throws Exception {
        Student student = findById(studentId);
        return dtoMapper.toValueResponse(student.getBalance());
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\SubjectService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.dto.response.SubjectResponse;
import com.tutoringplatform.dto.response.SubjectListResponse;
import com.tutoringplatform.dto.response.CategorySubjects;
import com.tutoringplatform.dto.response.info.SubjectInfo;
import com.tutoringplatform.repositories.interfaces.ISubjectRepository;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class SubjectService {
    private final ISubjectRepository subjectRepository;
    private final ITutorRepository tutorRepository;
    private final DTOMapper dtoMapper;

    @Autowired
    public SubjectService(ISubjectRepository subjectRepository, ITutorRepository tutorRepository, DTOMapper dtoMapper) {
        this.subjectRepository = subjectRepository;
        this.tutorRepository = tutorRepository;
        this.dtoMapper = dtoMapper;
    }

    public Subject createSubject(String name, String category) throws Exception {
        if (subjectRepository.findByName(name) != null) {
            throw new Exception("Subject already exists");
        }

        Subject subject = new Subject(name, category);
        subjectRepository.save(subject);
        return subject;
    }

    public Subject findById(String id) throws Exception {
        Subject subject = subjectRepository.findById(id);
        if (subject == null) {
            throw new Exception("Subject not found");
        }
        return subject;
    }

    public Subject findByName(String name) throws Exception {
        Subject subject = subjectRepository.findByName(name);
        if (subject == null) {
            throw new Exception("Subject not found");
        }
        return subject;
    }

    public List<Subject> findAll() {
        return subjectRepository.findAll();
    }

    public List<Subject> findByCategory(String category) {
        return subjectRepository.findByCategory(category);
    }

    public SubjectListResponse getAllSubjects() {
        List<Subject> allSubjects = subjectRepository.findAll();
        List<CategorySubjects> categorizedSubjects = groupSubjectsByCategory(allSubjects);
        return dtoMapper.toSubjectListResponse(categorizedSubjects);
    }

    public SubjectListResponse getAllSubjectsByCategory() {
        // Same as getAllSubjects since they both return subjects grouped by category
        return getAllSubjects();
    }

    public SubjectResponse getSubjectById(String id) throws Exception {
        Subject subject = findById(id); // This will throw exception if not found
        return dtoMapper.toSubjectResponse(subject);
    }

    public List<SubjectResponse> getAvailableSubjectsForTutor(String tutorId) throws Exception {
        // Find the tutor first
        Tutor tutor = tutorRepository.findById(tutorId);
        if (tutor == null) {
            throw new Exception("Tutor not found");
        }

        // Get all subjects and filter out the ones the tutor already teaches
        List<Subject> allSubjects = subjectRepository.findAll();
        List<Subject> tutorSubjects = tutor.getSubjects();
        
        List<Subject> availableSubjects = allSubjects.stream()
                .filter(subject -> !tutorSubjects.contains(subject))
                .collect(Collectors.toList());

        return availableSubjects.stream()
                .map(dtoMapper::toSubjectResponse)
                .collect(Collectors.toList());
    }

    private List<CategorySubjects> groupSubjectsByCategory(List<Subject> subjects) {
        // Group subjects by category
        Map<String, List<Subject>> subjectsByCategory = subjects.stream()
                .collect(Collectors.groupingBy(Subject::getCategory));

        // Convert to CategorySubjects DTOs
        return subjectsByCategory.entrySet().stream()
                .map(entry -> {
                    CategorySubjects categorySubjects = new CategorySubjects();
                    categorySubjects.setCategory(entry.getKey());
                    
                    List<SubjectInfo> subjectInfos = entry.getValue().stream()
                            .map(this::convertToSubjectInfo)
                            .collect(Collectors.toList());
                    
                    categorySubjects.setSubjects(subjectInfos);
                    return categorySubjects;
                })
                .collect(Collectors.toList());
    }

    private SubjectInfo convertToSubjectInfo(Subject subject) {
        SubjectInfo info = new SubjectInfo();
        info.setId(subject.getId());
        info.setName(subject.getName());
        
        // Calculate tutor count for this subject
        List<Tutor> tutorsForSubject = tutorRepository.findBySubject(subject);
        info.setTutorCount(tutorsForSubject.size());
        
        // Calculate average price for this subject
        double averagePrice = tutorsForSubject.stream()
                .mapToDouble(Tutor::getHourlyRate)
                .average()
                .orElse(0.0);
        info.setAveragePrice(averagePrice);
        
        return info;
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\TutorService.java
======================================================================

package com.tutoringplatform.services;

import com.tutoringplatform.dto.request.UpdateProfileRequest;
import com.tutoringplatform.dto.response.TutorProfileResponse;
import com.tutoringplatform.dto.response.ValueResponse;
import com.tutoringplatform.dto.response.SubjectResponse;
import com.tutoringplatform.models.availability.TutorAvailability;
import com.tutoringplatform.models.Tutor;
import com.tutoringplatform.models.Subject;
import com.tutoringplatform.models.Booking;
import com.tutoringplatform.models.Review;
import com.tutoringplatform.models.availability.RecurringAvailability;
import com.tutoringplatform.repositories.interfaces.ITutorRepository;
import com.tutoringplatform.repositories.interfaces.ISubjectRepository;
import com.tutoringplatform.repositories.interfaces.IBookingRepository;
import com.tutoringplatform.repositories.interfaces.IReviewRepository;
import com.tutoringplatform.repositories.interfaces.IAvailabilityRepository;
import com.tutoringplatform.util.DTOMapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.multipart.MultipartFile;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class TutorService extends UserService<Tutor> {

    private final ISubjectRepository subjectRepository;
    private final IBookingRepository bookingRepository;
    private final IReviewRepository reviewRepository;
    private final IAvailabilityRepository availabilityRepository;
    private final FileService fileService;
    private final PasswordEncoder passwordEncoder;
    private final DTOMapper dtoMapper;

    @Autowired
    public TutorService(
            ITutorRepository repository,
            ISubjectRepository subjectRepository,
            IBookingRepository bookingRepository,
            IReviewRepository reviewRepository,
            IAvailabilityRepository availabilityRepository,
            FileService fileService,
            PasswordEncoder passwordEncoder,
            DTOMapper dtoMapper) {
        super(repository);
        this.subjectRepository = subjectRepository;
        this.bookingRepository = bookingRepository;
        this.reviewRepository = reviewRepository;
        this.availabilityRepository = availabilityRepository;
        this.fileService = fileService;
        this.passwordEncoder = passwordEncoder;
        this.dtoMapper = dtoMapper;
    }

    public TutorProfileResponse getTutorProfile(String tutorId) throws Exception {
        Tutor tutor = findById(tutorId);

        // Get reviews
        List<Review> allReviews = reviewRepository.getTutorReviews(tutorId);

        // Calculate average rating
        double averageRating = allReviews.isEmpty() ? 0.0
                : allReviews.stream()
                        .mapToDouble(Review::getRating)
                        .average()
                        .orElse(0.0);

        // Count completed sessions
        List<Booking> bookings = bookingRepository.findByTutorId(tutorId);
        int completedSessions = (int) bookings.stream()
                .filter(b -> b.getStatus() == Booking.BookingStatus.COMPLETED)
                .count();

        // Map subjects
        List<SubjectResponse> subjects = tutor.getSubjects().stream()
                .map(dtoMapper::toSubjectResponse)
                .collect(Collectors.toList());

        // Get availability
        TutorAvailability availability = availabilityRepository.findByTutorId(tutorId);
        List<RecurringAvailability> recurringSlots = availability != null ? availability.getRecurringSlots()
                : new ArrayList<>();

        
        // Calculate joined date (would normally come from audit fields)
        LocalDate joinedDate = LocalDate.now().minusYears(1); // Placeholder

        return dtoMapper.toTutorProfileResponse(
                tutor,
                averageRating,
                allReviews.size(),
                subjects,
                recurringSlots,
                completedSessions,
                joinedDate);
    }

    public List<TutorProfileResponse> getAllTutorProfiles() throws Exception {
        List<Tutor> tutors = findAll();
        List<TutorProfileResponse> profiles = new ArrayList<>();

        for (Tutor tutor : tutors) {
            profiles.add(getTutorProfile(tutor.getId()));
        }

        return profiles;
    }

    @Transactional
    public TutorProfileResponse updateTutorProfile(String tutorId, UpdateProfileRequest request) throws Exception {
        Tutor tutor = findById(tutorId);

        // Update name if provided
        if (request.getName() != null && !request.getName().trim().isEmpty()) {
            tutor.setName(request.getName());
        }

        // Update email if provided and not taken
        if (request.getEmail() != null && !request.getEmail().isEmpty()) {
            Tutor existing = repository.findByEmail(request.getEmail());
            if (existing != null && !existing.getId().equals(tutorId)) {
                throw new Exception("Email already in use");
            }
            tutor.setEmail(request.getEmail());
        }

        // Update password if provided with current password verification
        if (request.getPassword() != null && !request.getPassword().isEmpty()) {
            if (request.getCurrentPassword() == null || request.getCurrentPassword().isEmpty()) {
                throw new Exception("Current password required to change password");
            }

            if (!passwordEncoder.matches(request.getCurrentPassword(), tutor.getPassword())) {
                throw new Exception("Current password is incorrect");
            }

            tutor.setPassword(passwordEncoder.encode(request.getPassword()));
        }

        // Update timezone if provided
        if (request.getTimeZoneId() != null) {
            try {
                ZoneId zone = ZoneId.of(request.getTimeZoneId());
                tutor.setTimeZone(zone);
            } catch (Exception e) {
                throw new Exception("Invalid timezone");
            }
        }

        // Update tutor-specific fields
        if (request.getHourlyRate() != null) {
            if (request.getHourlyRate() <= 0) {
                throw new Exception("Hourly rate must be positive");
            }
            tutor.setHourlyRate(request.getHourlyRate());
        }

        if (request.getDescription() != null && !request.getDescription().trim().isEmpty()) {
            tutor.setDescription(request.getDescription());
        }

        repository.update(tutor);

        return getTutorProfile(tutorId);
    }

    @Transactional
    public Map<String, String> updateProfilePicture(String tutorId, MultipartFile file) throws Exception {
        Tutor tutor = findById(tutorId);

        // Delete old profile picture if exists
        if (tutor.getProfilePictureId() != null) {
            try {
                fileService.deleteFile(tutor.getProfilePictureId());
            } catch (Exception e) {
                // Log error but continue
            }
        }

        // Store new profile picture
        String fileId = fileService.storeFile(tutorId, file, "profile");
        tutor.setProfilePictureId(fileId);
        repository.update(tutor);

        Map<String, String> result = new HashMap<>();
        result.put("profilePictureId", fileId);
        result.put("profilePictureUrl", "/api/files/" + fileId);

        return result;
    }

    @Transactional
    public TutorProfileResponse addSubjectToTutor(String tutorId, String subjectId) throws Exception {
        Tutor tutor = findById(tutorId);
        Subject subject = subjectRepository.findById(subjectId);

        if (subject == null) {
            throw new Exception("Subject not found");
        }

        if (tutor.getSubjects().contains(subject)) {
            throw new Exception("Tutor already teaches this subject");
        }

        tutor.addSubject(subject);
        repository.update(tutor);

        return getTutorProfile(tutorId);
    }

    @Transactional
    public TutorProfileResponse removeSubjectFromTutor(String tutorId, String subjectId) throws Exception {
        Tutor tutor = findById(tutorId);
        Subject subject = subjectRepository.findById(subjectId);

        if (subject == null) {
            throw new Exception("Subject not found");
        }

        if (!tutor.getSubjects().contains(subject)) {
            throw new Exception("Tutor does not teach this subject");
        }

        // Check if there are any bookings for this subject
        List<Booking> bookingsForSubject = bookingRepository.findByTutorIdAndSubjectId(tutorId, subjectId);
        if (!bookingsForSubject.isEmpty()) {
            throw new Exception("Cannot remove subject with existing bookings");
        }

        tutor.removeSubject(subject);
        repository.update(tutor);

        return getTutorProfile(tutorId);
    }

    public ValueResponse<Double> getEarnings(String tutorId) throws Exception {
        Tutor tutor = findById(tutorId);
        return dtoMapper.toValueResponse(tutor.getEarnings());
    }

    public ValueResponse<Double> getAverageRating(String tutorId) throws Exception {
        List<Review> reviews = reviewRepository.getTutorReviews(tutorId);

        double averageRating = reviews.isEmpty() ? 0.0
                : reviews.stream()
                        .mapToDouble(Review::getRating)
                        .average()
                        .orElse(0.0);

        return dtoMapper.toValueResponse(averageRating);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\services\UserService.java
======================================================================

package com.tutoringplatform.services;

import java.util.List;

import com.tutoringplatform.models.User;
import com.tutoringplatform.repositories.interfaces.IUserRepository;

public abstract class UserService<T extends User> {
    protected IUserRepository<T> repository;

    public UserService(IUserRepository<T> repository) {
        this.repository = repository;
    }

    public T findById(String id) throws Exception {
        T user = repository.findById(id);
        if (user == null) {
            throw new Exception("User not found with id: " + id);
        }
        return user;
    }

    public T findByEmail(String email) throws Exception {
        T user = repository.findByEmail(email);
        if (user == null) {
            throw new Exception("User not found with email: " + email);
        }
        return user;
    }

    public List<T> findAll() {
        return repository.findAll();
    }

    public void update(T user) throws Exception {
        if (repository.findById(user.getId()) == null) {
            throw new Exception("User not found");
        }
        repository.update(user);
    }

    public void delete(String id) throws Exception {
        if (repository.findById(id) == null) {
            throw new Exception("User not found");
        }
        repository.delete(id);
    }
}



======================================================================
// FILE: java\com\tutoringplatform\util\DTOMapper.java
======================================================================

package com.tutoringplatform.util;

import com.tutoringplatform.dto.response.*;
import com.tutoringplatform.dto.response.info.PaymentInfo;
import com.tutoringplatform.dto.response.info.TutorInfo;
import com.tutoringplatform.dto.response.info.TutorSearchResultInfo;
import com.tutoringplatform.dto.response.info.UserInfo;
import com.tutoringplatform.models.*;
import com.tutoringplatform.models.availability.RecurringAvailability;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import java.util.List;
import java.util.stream.Collectors;
import com.tutoringplatform.config.AppProperties;
import com.tutoringplatform.models.availability.AvailabilityException;

@Component
public class DTOMapper {

    @Autowired
    private AppProperties appProperties;

    // ========== AUTH RESPONSES ==========

    public AuthResponse toAuthResponse(User user, double balance, double hourlyRate) {
        AuthResponse response = new AuthResponse();
        response.setId(user.getId());
        response.setName(user.getName());
        response.setEmail(user.getEmail());
        response.setUserType(user.getUserType().getDisplayName());
        response.setTimeZoneId(user.getTimeZoneId());
        response.setProfilePictureUrl(buildProfilePictureUrl(user.getProfilePictureId()));
        response.setBalance(balance); // Only for students
        response.setHourlyRate(hourlyRate); // Only for tutors
        return response;
    }

    // ========== DASHBOARD RESPONSES ==========

    public StudentDashboardResponse toStudentDashboardResponse(
            UserProfile profile,
            DashboardStats stats,
            List<BookingDetailResponse> upcomingBookings) {

        StudentDashboardResponse response = new StudentDashboardResponse();
        response.setProfile(profile);
        response.setStats(stats);
        response.setUpcomingBookings(upcomingBookings);

        return response;
    }

    public TutorDashboardResponse toTutorDashboardResponse(
            UserProfile profile,
            DashboardStats stats,
            List<BookingDetailResponse> upcomingBookings,
            List<ReviewResponse> recentReviews,
            List<BookingDetailResponse> todaysSchedule) {

        TutorDashboardResponse response = new TutorDashboardResponse();
        response.setProfile(profile);
        response.setStats(stats);
        response.setUpcomingBookings(upcomingBookings);
        response.setTodaysSchedule(todaysSchedule);

        return response;
    }

    // ========== BOOKING RESPONSES ==========

    public BookingDetailResponse toBookingDetailResponse(
            Booking booking,
            Student student,
            Tutor tutor,
            Payment payment) {

        BookingDetailResponse response = new BookingDetailResponse();
        response.setId(booking.getId());

        // Student info
        UserInfo studentInfo = new UserInfo();
        studentInfo.setId(student.getId());
        studentInfo.setName(student.getName());
        studentInfo.setProfilePictureUrl(buildProfilePictureUrl(student.getProfilePictureId()));
        response.setStudent(studentInfo);

        // Tutor info
        TutorInfo tutorInfo = new TutorInfo();
        tutorInfo.setId(tutor.getId());
        tutorInfo.setName(tutor.getName());
        tutorInfo.setProfilePictureUrl(buildProfilePictureUrl(tutor.getProfilePictureId()));
        tutorInfo.setHourlyRate(tutor.getHourlyRate());
        response.setTutor(tutorInfo);

        // Subject
        response.setSubject(toSubjectResponse(booking.getSubject()));

        response.setDateTime(booking.getDateTime());
        response.setDurationHours(booking.getDurationHours());
        response.setTotalCost(booking.getTotalCost());
        response.setStatus(booking.getStatus().toString());

        // Payment info (if exists)
        if (payment != null) {
            PaymentInfo paymentInfo = new PaymentInfo();
            paymentInfo.setStatus(payment.getStatus().toString());
            paymentInfo.setPaidAt(payment.getTimestamp());
            response.setPayment(paymentInfo);
        }

        return response;
    }

    public BookingListResponse toBookingListResponse(
            List<BookingDetailResponse> upcomingBookings,
            List<BookingDetailResponse> pastBookings,
            List<BookingDetailResponse> cancelledBookings) {

        BookingListResponse response = new BookingListResponse();
        response.setUpcomingBookings(upcomingBookings);
        response.setPastBookings(pastBookings);
        response.setCancelledBookings(cancelledBookings);
        return response;
    }

    // ========== PROFILE RESPONSES ==========

    public TutorProfileResponse toTutorProfileResponse(
            Tutor tutor,
            double averageRating,
            int totalReviews,
            List<SubjectResponse> subjects,
            List<RecurringAvailability> availability,
            int completedSessions,
            java.time.LocalDate joinedDate) {

        TutorProfileResponse response = new TutorProfileResponse();
        response.setId(tutor.getId());
        response.setName(tutor.getName());
        response.setEmail(tutor.getEmail());
        response.setProfilePictureUrl(buildProfilePictureUrl(tutor.getProfilePictureId()));
        response.setHourlyRate(tutor.getHourlyRate());
        response.setDescription(tutor.getDescription());
        response.setRating(averageRating);
        response.setTotalReviews(totalReviews);
        response.setSubjects(subjects);
        response.setAvailability(availability);
        response.setCompletedSessions(completedSessions);
        response.setJoinedDate(joinedDate);

        return response;
    }

    public StudentProfileResponse toStudentProfileResponse(
            Student student,
            java.time.LocalDate joinedDate,
            int totalSessions) {

        StudentProfileResponse response = new StudentProfileResponse();
        response.setId(student.getId());
        response.setName(student.getName());
        response.setEmail(student.getEmail());
        response.setProfilePictureUrl(buildProfilePictureUrl(student.getProfilePictureId()));
        response.setBalance(student.getBalance());
        response.setTimeZoneId(student.getTimeZoneId());
        response.setJoinedDate(joinedDate);
        response.setTotalSessions(totalSessions);

        return response;
    }

    // ========== SEARCH RESPONSES ==========

    public TutorSearchResultsResponse toTutorSearchResultsResponse(
            List<TutorSearchResultInfo> results,
            int totalCount,
            SearchFilters appliedFilters) {

        TutorSearchResultsResponse response = new TutorSearchResultsResponse();
        response.setResults(results);
        response.setTotalCount(totalCount);
        response.setFilters(appliedFilters);
        return response;
    }

    public TutorSearchResultInfo toTutorSearchResult(
            Tutor tutor,
            double rating,
            int reviewCount,
            String shortDescription,
            java.time.LocalDateTime nextAvailable) {

        TutorSearchResultInfo result = new TutorSearchResultInfo();
        result.setId(tutor.getId());
        result.setName(tutor.getName());
        result.setProfilePictureUrl(buildProfilePictureUrl(tutor.getProfilePictureId()));
        result.setHourlyRate(tutor.getHourlyRate());
        result.setRating(rating);
        result.setReviewCount(reviewCount);
        result.setSubjects(tutor.getSubjects().stream()
                .map(this::toSubjectResponse)
                .collect(Collectors.toList()));
        result.setShortDescription(shortDescription);
        result.setNextAvailable(nextAvailable);

        return result;
    }

    // ========== SUBJECT RESPONSES ==========

    public SubjectResponse toSubjectResponse(Subject subject) {
        SubjectResponse response = new SubjectResponse();
        response.setId(subject.getId());
        response.setName(subject.getName());
        response.setCategory(subject.getCategory());
        return response;
    }

    public SubjectListResponse toSubjectListResponse(List<CategorySubjects> categorizedSubjects) {
        SubjectListResponse response = new SubjectListResponse();
        response.setSubjects(categorizedSubjects);
        return response;
    }

    // ========== REVIEW RESPONSES ==========

    public ReviewResponse toReviewResponse(
            Review review,
            Student student,
            Tutor tutor) {

        ReviewResponse response = new ReviewResponse();
        response.setId(review.getId());

        // Student info
        UserInfo studentInfo = new UserInfo();
        studentInfo.setId(student.getId());
        studentInfo.setName(student.getName());
        studentInfo.setProfilePictureUrl(buildProfilePictureUrl(student.getProfilePictureId()));
        response.setStudentInfo(studentInfo);

        // Tutor info (minimal)
        UserInfo tutorInfo = new UserInfo();
        tutorInfo.setId(tutor.getId());
        tutorInfo.setName(tutor.getName());
        response.setTutorInfo(tutorInfo);

        response.setRating(review.getRating());
        response.setComment(review.getComment());
        response.setCreatedAt(review.getTimestamp());

        return response;
    }

    // ========== PAYMENT RESPONSES ==========

    public PaymentHistoryResponse toPaymentHistoryResponse(
            List<TransactionRecord> transactions,
            double totalSpent,
            double currentBalance) {

        PaymentHistoryResponse response = new PaymentHistoryResponse();
        response.setTransactions(transactions);
        response.setTotalSpent(totalSpent);
        response.setCurrentBalance(currentBalance);
        return response;
    }

    // ========== AVAILABILITY RESPONSES ==========

    public AvailabilityResponse toAvailabilityResponse(
            String tutorId,
            java.time.ZoneId timeZone,
            List<RecurringAvailability> regularSchedule,
            List<AvailabilityException> exceptions,
            java.time.LocalDateTime nextAvailableSlot) {

        AvailabilityResponse response = new AvailabilityResponse();
        response.setTutorId(tutorId);
        response.setTimeZone(timeZone.toString());
        response.setRegularSchedule(regularSchedule);
        response.setExceptions(exceptions);
        response.setNextAvailableSlot(nextAvailableSlot);
        return response;
    }

    // ========== VALUE RESPONSE ==========

    public <T> ValueResponse<T> toValueResponse(T value) {
        ValueResponse<T> response = new ValueResponse<>();
        response.setValue(value);
        return response;
    }

    public <T> ValueResponse<T> toValueResponse(T value, String message) {
        ValueResponse<T> response = new ValueResponse<>();
        response.setValue(value);
        response.setMessage(message);
        return response;
    }

    // ========== HELPER METHODS ==========

    public String buildProfilePictureUrl(String profilePictureId) {
        if (profilePictureId == null) {
            return appProperties.getApi().getFilesBaseUrl() + "default-avatar";
        }
        return appProperties.getApi().getFilesBaseUrl() + profilePictureId;
    }
}



